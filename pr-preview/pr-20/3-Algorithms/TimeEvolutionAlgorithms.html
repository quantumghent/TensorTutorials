



<!DOCTYPE html>


<html lang="en" data-theme="light 
">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>12. Time Evolution &#8212; TensorTutorials</title>
    
    <script src="https://unpkg.com/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6.3.1/dist/tippy-bundle.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    
        <script>
            MathJax = {
            loader: {load: ['[tex]/boldsymbol', '[tex]/textmacros']},
            tex: {
                packages: {'[+]': ['boldsymbol', 'textmacros']},
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                processEscapes: true,
                macros: {
                    "argmax" : "arg\\,max",
                    "argmin" : "arg\\,min",
                    "col"    : "col",
                    "Span"   :  "span",
                    "epsilon": "\\varepsilon",
                    "EE": "\\mathbb{E}",
                    "PP": "\\mathbb{P}",
                    "RR": "\\mathbb{R}",
                    "NN": "\\mathbb{N}",
                    "ZZ": "\\mathbb{Z}",
                    "aA": "\\mathcal{A}",
                    "bB": "\\mathcal{B}",
                    "cC": "\\mathcal{C}",
                    "dD": "\\mathcal{D}",
                    "eE": "\\mathcal{E}",
                    "fF": "\\mathcal{F}",
                    "gG": "\\mathcal{G}",
                    "hH": "\\mathcal{H}",
                }
            },
            svg: {
                fontCache: 'global',
                scale: 0.92,
                displayAlign: "center",
            },
            };
        </script>
    
    
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light 
";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=ac02cc09edc035673794" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/quantumghent-book-theme.5e19e0a6c2e2247c14aaae6dbdd37c4f.css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=ac02cc09edc035673794" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794" />
  <script src="../_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=ac02cc09edc035673794"></script>


    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script src="../_static/quantumghent-book-theme.ef2ef6c3e8da75e1e736fb5fce08cde6.js"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-3PCWRLGWND"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-3PCWRLGWND');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"argmax": "arg\\,max", "argmin": "arg\\,min"}, "packages": {"[+]": ["physics"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '3-Algorithms/TimeEvolutionAlgorithms';</script>
    <link rel="canonical" href="https://quantumghent.github.io/TensorTutorials/3-Algorithms/TimeEvolutionAlgorithms.html" />
    <link rel="shortcut icon" href="../_static/lectures-favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="13. References" href="../References.html" />
    <link rel="prev" title="11. Fixed-Point algorithms" href="FixedpointAlgorithms.html" />

<!-- Normal Meta Tags -->
<meta name="author" context="Jacob Bridgeman, Lander Burgelman, Lukas Devos, Jutho Haegeman, Daan Maertens, Bram Vancraeynest-De Cuiper and Kevin Vervoort" />
<meta name="keywords" content="Julia, Tensor Networks, Quantum Many-Body Physics, Statistical Mechanics" />
<meta name="description" content=This website presents a set of lectures on Tensor Network methods />

<!-- Twitter tags -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@" />
<meta name="twitter:title" content="Time Evolution"/>
<meta name="twitter:description" content="This website presents a set of lectures on Tensor Network methods">
<meta name="twitter:creator" content="@">
<meta name="twitter:image" content="">

<!-- Opengraph tags -->
<meta property="og:title" content="Time Evolution" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://quantumghent.github.io/TensorTutorials/3-Algorithms/TimeEvolutionAlgorithms.html" />
<meta property="og:image" content="" />
<meta property="og:description" content="This website presents a set of lectures on Tensor Network methods" />
<meta property="og:site_name" content="TensorTutorials" />
<meta name="theme-color" content="#ffffff" />

  </head>
<body>


    <span id="top"></span>

    <div class="qe-wrapper">

        <div class="qe-main">

            <div class="qe-page" id=3-Algorithms/TimeEvolutionAlgorithms>

                <div class="qe-page__toc">

                    <div class="inner">

                        
                        <div class="qe-page__toc-header">
                            On this page
                        </div>


                        <nav id="bd-toc-nav" class="qe-page__toc-nav">
                            <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tdvp">12.1. TDVP</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#time-evolution-mpo">12.2. Time Evolution MPO</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#imaginary-time-evolution">12.3. Imaginary Time Evolution</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#finite-temperature">12.4. Finite Temperature</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#code-example-mpskit-timestep-make-time-mpo">12.5. Code Example: <code class="docutils literal notranslate"><span class="pre">MPSKit.timestep,make_time_mpo</span></code></a></li>
</ul>
                            <p class="logo">
                                
                                    
                                    <a href=https://quantumghent.github.io/><img src="../_static/logo.png" class="logo" alt="logo"></a>
                                    
                                
                            </p>

                            <p class="powered">Powered by <a href="https://jupyterbook.org/">Jupyter Book</a></p>

                        </nav>

                        <div class="qe-page__toc-footer">
                            
                            
                            <p><a href="#top"><strong>Back to top</strong></a></p>
                        </div>

                    </div>

                </div>

                <div class="qe-page__header">

                    <div class="qe-page__header-copy">

                        <p class="qe-page__header-heading"><a href="../intro.html">TensorTutorials</a></p>

                        <p class="qe-page__header-subheading">Time Evolution</p>

                    </div>

                    <p class="qe-page__header-authors">Jacob Bridgeman, Lander Burgelman, Lukas Devos, Jutho Haegeman, Daan Maertens, Bram Vancraeynest-De Cuiper and Kevin Vervoort</p>

                </div> <!-- .page__header -->



                
                <main class="qe-page__content" role="main">
                    
                    <div>
                        
  <div class="tex2jax_ignore mathjax_ignore section" id="time-evolution">
<h1><a class="toc-backref" href="#id11"><span class="section-number">12. </span>Time Evolution</a><a class="headerlink" href="#time-evolution" title="Permalink to this heading">#</a></h1>
<p>In this segment of the tutorial, we delve into some time evolution techniques for MPS. In
particular we will focus on the <a class="reference internal" href="#tdvp-header"><span class="std std-ref">TDVP</span></a> and <a class="reference internal" href="#tmpo-header"><span class="std std-ref">Time Evolution MPO</span></a>
methods. Another method (i)<span class="xref myst">TEBD</span> has already been explained in an earlier section.
Following this we briefly explain how <a class="reference internal" href="#imag-header"><span class="std std-ref">imaginary time evolution</span></a> can be used to
find ground states and how <a class="reference internal" href="#fintemp-header"><span class="std std-ref">thermal density matrices</span></a> can be simulated using
MPS. At the end of this section we offer some basic <a class="reference internal" href="#code-header"><span class="std std-ref">code examples</span></a>.</p>
<p>In the case of quantum many body systems time evolution amounts to solving the time
dependent Schrodinger equation</p>
<div class="math notranslate nohighlight" id="equation-schrodinger">
<span class="eqno">(12.1)<a class="headerlink" href="#equation-schrodinger" title="Permalink to this equation">#</a></span>\[i \frac{\partial}{\partial t} \ket{\Psi(t)}= \hat{H}\ket{\Psi(t)}\]</div>
<p>for a given Hamiltonian <span class="math notranslate nohighlight">\(\hat{H}\)</span> with initial condition <span class="math notranslate nohighlight">\(\ket{\Psi_0}=\ket{\Psi(t_0)}\)</span>. For
a time independent Hamiltonian the solution is given by</p>
<div class="math notranslate nohighlight">
\[\ket{\Psi(t)} = U(t)\ket{\Psi_0} = \exp(-it\hat{H})\ket{\Psi_0}\]</div>
<p>By approximating the time evolution operator <span class="math notranslate nohighlight">\(U\)</span> in the Tensor Network language, we can also
study real-time dynamics.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>One should keep in mind that time evolution in general will increase the entanglement of the
state so that in practice time evolution can only be done with Tensor Networks for
relatively modest times. For example in case of a quench the entanglement for 1D systems
grows as <span class="math notranslate nohighlight">\(S \sim t\)</span> , (see <span id="id1">[<a class="reference internal" href="../References.html#id11" title="Pasquale Calabrese and John Cardy. Evolution of entanglement entropy in one-dimensional systems. Journal of Statistical Mechanics: Theory and Experiment, 2005(04):P04010, 2005. arXiv:cond-mat/0503393, doi:10.1088/1742-5468/2005/04/p04010.">Calabrese and Cardy, 2005</a>]</span>) so that the bond dimension <span class="math notranslate nohighlight">\(D \sim
\exp(at)\)</span> in order to accurately follow the dynamics.</p>
</div>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#time-evolution" id="id11">Time Evolution</a></p>
<ul>
<li><p><a class="reference internal" href="#tdvp" id="id12">TDVP</a></p></li>
<li><p><a class="reference internal" href="#time-evolution-mpo" id="id13">Time Evolution MPO</a></p></li>
<li><p><a class="reference internal" href="#imaginary-time-evolution" id="id14">Imaginary Time Evolution</a></p></li>
<li><p><a class="reference internal" href="#finite-temperature" id="id15">Finite Temperature</a></p></li>
<li><p><a class="reference internal" href="#code-example-mpskit-timestep-make-time-mpo" id="id16">Code Example: <code class="docutils literal notranslate"><span class="pre">MPSKit.timestep,make_time_mpo</span></code></a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="tdvp">
<span id="tdvp-header"></span><h2><a class="toc-backref" href="#id12"><span class="section-number">12.1. </span>TDVP</a><a class="headerlink" href="#tdvp" title="Permalink to this heading">#</a></h2>
<p>The Time-Dependent Variational Principle is an old concept, originaly developed by Dirac and
Frenkel in the 1930’s. The idea is to solve the schrodinger equation by minimizing</p>
<div class="math notranslate nohighlight">
\[\|i \frac{\partial}{\partial t} \ket{\Psi(t)}- \hat{H}\ket{\Psi(t)}\|^2\]</div>
<p>In the case of MPS, we can parametrize the state <span class="math notranslate nohighlight">\(\ket{\Psi(t)}\)</span> by a set of time dependent
matrices <span class="math notranslate nohighlight">\(\{A_1(t),A_2(t),\dots A_N(t)\}\)</span> (where N is the system size for finiteMPS or the
size of the unit cell for infinite MPS). In other words the state <span class="math notranslate nohighlight">\(\ket{\Psi(t)}\)</span> lives in a
manifold determined by these matrices, the MPS-manifold. Geometrically the solution of the
minimization problem is given by the projection of the RHS of the schrodinger equation onto
the MPS manifold</p>
<div class="math notranslate nohighlight" id="equation-tdvpeq">
<span class="eqno">(12.2)<a class="headerlink" href="#equation-tdvpeq" title="Permalink to this equation">#</a></span>\[\frac{d}{dt} \ket{\Psi(A)} = -i \hat{P}_{T\ket{\Psi(A)}} \hat{H}\ket{\Psi(A)}\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{P}_{T\ket{\Psi(A)}}\)</span> is the operator that projects the state onto the tangent
space. As a consequence the time-evolving state will never leave the MPS manifold and
parametrization in terms of <span class="math notranslate nohighlight">\(A(t)\)</span> makes sense. One can in principle work out the above
equation on the level of the <span class="math notranslate nohighlight">\(A\)</span> matrices and try to solve the above equation. This gives a
complicated set of (non-linear) equations that can be solved by one’s favourite finite
difference scheme, but requires the inversion of matrices with small singular values (and
thus numerical instabilities) <span id="id2">[<a class="reference internal" href="../References.html#id5" title="Jutho Haegeman, J Ignacio Cirac, Tobias J Osborne, Iztok Pižorn, Henri Verschelde, and Frank Verstraete. Time-dependent variational principle for quantum lattices. Physical Review Letters, 107(7):070601, 2011. arXiv:1103.0936, doi:10.1103/PhysRevLett.107.070601.">Haegeman <em>et al.</em>, 2011</a>]</span>, <span id="id3">[<a class="reference internal" href="../References.html#id13" title="Jutho Haegeman, Christian Lubich, Ivan Oseledets, Bart Vandereycken, and Frank Verstraete. Unifying time evolution and optimization with matrix product states. Physical Review B, 94:165116, 2016. arXiv:1408.5056, doi:10.1103/PhysRevB.94.165116.">Haegeman <em>et al.</em>, 2016</a>]</span>. Instead, it
turns out that a natural and inversion free way of solving this equation is possible if we
use the gauge freedom of MPS.</p>
<p>For a finite MPS, one can show that in the mixed gauge the action of the projection operator
onto <span class="math notranslate nohighlight">\(\hat{H}\ket{\Psi(A)}\)</span> is given by <span id="id4">[<a class="reference internal" href="../References.html#id4" title="Laurens Vanderstraeten, Jutho Haegeman, and Frank Verstraete. Tangent-space methods for uniform matrix product states. SciPost Physics Lecture Notes, pages 007, 2019. arXiv:1810.07006, doi:10.21468/SciPostPhysLectNotes.7.">Vanderstraeten <em>et al.</em>, 2019</a>]</span></p>
<img alt="../_images/TDVPProjector.png" class="align-center" id="tdvpprojector" src="../_images/TDVPProjector.png" />
<p>The projector action consists of two sums, one where each term acts on the <span class="math notranslate nohighlight">\(A_C\)</span> on site <span class="math notranslate nohighlight">\(n\)</span>
and the other on the bond tensor <span class="math notranslate nohighlight">\(C\)</span> to the right of it. As a result <a class="reference internal" href="#equation-tdvpeq">(12.2)</a> now
resembles an ODE of the form</p>
<div class="math notranslate nohighlight" id="equation-splittingode">
<span class="eqno">(12.3)<a class="headerlink" href="#equation-splittingode" title="Permalink to this equation">#</a></span>\[\frac{d}{dt} Y = A(Y) + B(Y)\]</div>
<p>This type of ODE can be solved by a splitting method <span id="id5">[<a class="reference internal" href="../References.html#id12" title="Christian Lubich, Ivan V. Oseledets, and Bart Vandereycken. Time integration of tensor trains. SIAM Journal on Numerical Analysis, 53(2):917–941, 2015. arXiv:1407.2042, doi:10.1137/140976546.">Lubich <em>et al.</em>, 2015</a>]</span> i.e. we solve
<span class="math notranslate nohighlight">\(\frac{d}{dt} Y = A(Y)\)</span> and <span class="math notranslate nohighlight">\(\frac{d}{dt} Y = B(Y)\)</span> seperately and then combine the two
results to obtain an approximate solution to <a class="reference internal" href="#equation-splittingode">(12.3)</a>. Applying this idea to
<a class="reference internal" href="#equation-tdvpeq">(12.2)</a> we thus need to solve equations of the form</p>
<div class="math notranslate nohighlight">
\[\frac{d}{dt} \ket{\Psi(A)} = -i \hat{H}_{eff}^{A_C}[ A_C(n)]\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\frac{d}{dt} \ket{\Psi(A)}= i \hat{H}_{eff}^{C}[ C(n)]
\]</div>
<p>These can be further simplified by noting that we can put all the time dependence inside one
tensor, which we choose to be either <span class="math notranslate nohighlight">\(A_C(n)\)</span> or <span class="math notranslate nohighlight">\(C(n)\)</span>. It is then sufficient to solve</p>
<div class="math notranslate nohighlight" id="equation-acdot">
<span class="eqno">(12.4)<a class="headerlink" href="#equation-acdot" title="Permalink to this equation">#</a></span>\[\dot{A}_C(n) = -i \hat{H}_{eff}^{A_C}[ A_C(n)]\]</div>
<p>and</p>
<div class="math notranslate nohighlight" id="equation-cdot">
<span class="eqno">(12.5)<a class="headerlink" href="#equation-cdot" title="Permalink to this equation">#</a></span>\[\dot{C}(n) = i \hat{H}_{eff}^{C}[ C(n)]\]</div>
<p>for each site <span class="math notranslate nohighlight">\(n\)</span> seperately. These can be integrated exactly to give</p>
<div class="math notranslate nohighlight" id="equation-acdt">
<span class="eqno">(12.6)<a class="headerlink" href="#equation-acdt" title="Permalink to this equation">#</a></span>\[A_C(n,t+dt) = \exp(-idt \hat{H}_{\text{eff}}^{A_C}) A_C(n,t)\]</div>
<p>and</p>
<div class="math notranslate nohighlight" id="equation-cdt">
<span class="eqno">(12.7)<a class="headerlink" href="#equation-cdt" title="Permalink to this equation">#</a></span>\[C(n,t+dt) = \exp(idt \hat{H}_{\text{eff}}^{C}) C(n,t)\]</div>
<p>A natural way to combine the seperate solutions is to perform a sweep-like update. Starting
from the first site we do:</p>
<div class="admonition-tdvp-algorithm-for-finite-mps admonition">
<p class="admonition-title">TDVP algorithm for finite MPS</p>
<ol class="arabic simple">
<li><p>Update <span class="math notranslate nohighlight">\(A_C(n)\)</span> according to <a class="reference internal" href="#equation-acdt">(12.6)</a>.</p></li>
<li><p>QR the resulting new <span class="math notranslate nohighlight">\(A_C(n,t+dt)\)</span> to get a new updated <span class="math notranslate nohighlight">\(A_L(n,t+dt)\)</span> en <span class="math notranslate nohighlight">\(C(n,t+dt)\)</span>.</p></li>
<li><p>Update the new <span class="math notranslate nohighlight">\(C(n,t+dt)\)</span> via <a class="reference internal" href="#equation-cdt">(12.7)</a> to get an <span class="math notranslate nohighlight">\(\tilde{C}\)</span>.</p></li>
<li><p>Absorb <span class="math notranslate nohighlight">\(\tilde{C}\)</span> into <span class="math notranslate nohighlight">\(A_R(n+1,t)\)</span> to get a new <span class="math notranslate nohighlight">\(A_C(n+1,t)\)</span></p></li>
<li><p>Repeat for n+1</p></li>
</ol>
</div>
<p>At the end of the chain one only updates the <span class="math notranslate nohighlight">\(A_C\)</span> since there is no <span class="math notranslate nohighlight">\(C\)</span> there.</p>
<p>Doing the above left to right sweep gives a first order integrator i.e. we have solved the
time evolution up to order <span class="math notranslate nohighlight">\(\mathcal{O}(dt^2)\)</span>. Since the terms can be solved in any order
we can also perform a reverse sweep i.e. working from right to left. Combining this with the
left to right sweep yields a second order integrator (because the reverse sweep is the
adjoint of the forwards sweep).</p>
<p>For an infinite MPS one could also do a sweep-like update until some criteria converges to
obtain new tensors <span class="math notranslate nohighlight">\(\{A_L,C,A_C,A_R\}\)</span>. However this can be costly since one has to iterate
until convergence. Instead we can exploit the translational invariance of the system by
demanding that <span class="math notranslate nohighlight">\(C=\tilde{C}\)</span>. Since <span class="math notranslate nohighlight">\(\tilde{C}=\exp(idt \hat{H}_{\text{eff}}^{C}) C(n,t+dt)\)</span>
we can turn things around and find</p>
<div class="math notranslate nohighlight">
\[C(n,t+dt)=\exp(-idt \hat{H}_{\text{eff}}^{C}) C(n)\]</div>
<p>Given the newly found <span class="math notranslate nohighlight">\(C(n,t+dt)\)</span> and <span class="math notranslate nohighlight">\(A_C(n,t+dt)\)</span> one can determine a new <span class="math notranslate nohighlight">\(A_L\)</span>, giving a
MPS for <span class="math notranslate nohighlight">\(t+dt\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike other time evolution methods, TDVP retains some of the physical properties of the
Schrodinger equation it is trying to solve. First of all, it acts trivial on (numerical)
eigenstates of <span class="math notranslate nohighlight">\(\hat{H}\)</span> since then <span class="math notranslate nohighlight">\(\hat{H}_{\text{eff}}^{A_C}[A_C] \propto A_C\)</span> and the
whole MPS picks up a phase equal to <span class="math notranslate nohighlight">\(e^{-i dtE}\)</span>. In addition it conserves energy and is
time-reversible for time-independent Hamiltonians <span id="id6">[<a class="reference internal" href="../References.html#id4" title="Laurens Vanderstraeten, Jutho Haegeman, and Frank Verstraete. Tangent-space methods for uniform matrix product states. SciPost Physics Lecture Notes, pages 007, 2019. arXiv:1810.07006, doi:10.21468/SciPostPhysLectNotes.7.">Vanderstraeten <em>et al.</em>, 2019</a>]</span>.</p>
</div>
</div>
<div class="section" id="time-evolution-mpo">
<span id="tmpo-header"></span><h2><a class="toc-backref" href="#id13"><span class="section-number">12.2. </span>Time Evolution MPO</a><a class="headerlink" href="#time-evolution-mpo" title="Permalink to this heading">#</a></h2>
<p>Perhaps the most natural way to perform the time evolution would be to write the time
evolution operator as a MPO. The evolved state would then simply be the contraction of this
MPO onto an MPS (see ref). The exponential implementing the time evolution can be
approximated up to any order by its trunctated Taylor series</p>
<div class="math notranslate nohighlight">
\[\exp(-\tau\hat{H}) = \hat{1} + \tau\hat{H} + \frac{\tau^2}{2}\hat{H}^2 + \mathcal{O}(\tau^3)\]</div>
<p>The MPO approximation of the time evolution operator then boils down to implementing powers
of <span class="math notranslate nohighlight">\(\hat{H}\)</span> in an efficient (i.e. with the lowest possible MPO bond dimension) and
size-extensive way <span id="id7">[<a class="reference internal" href="../References.html#id9" title="Maarten Van Damme, Jutho Haegeman, Ian McCulloch, and Laurens Vanderstraeten. Efficient higher-order matrix product operators for time evolution. 2023. arXiv:2302.14181.">Damme <em>et al.</em>, 2023</a>]</span>. For example, for a MPO Hamiltonian of the
form</p>
<img alt="../_images/MPOHam.png" class="align-center" id="mpoham" src="../_images/MPOHam.png" />
<p>which corresponds to the Hamiltonian</p>
<div class="math notranslate nohighlight">
\[\hat{H} = \sum_i \hat{D}_i + \hat{C}_i \hat{B}_{i+1}\]</div>
<p>The first order approximation of <span class="math notranslate nohighlight">\(U=\exp(-\tau\hat{H})\)</span> is given in MPO form by</p>
<img alt="../_images/TimeMPO_1stOrder.png" class="align-center" id="firstorder" src="../_images/TimeMPO_1stOrder.png" />
<p>Doing the matrix multiplcation (and remembering that for MPO the boundary conditions are so
the we need to track the upper left expression) we find</p>
<div class="math notranslate nohighlight">
\[\exp(-\tau\hat{H}) \approx \hat{1} + \tau \left(\sum_i D_i + C_i B_{i+1}\right) = \hat{1} +
\tau \hat{H}\]</div>
<p>as desired.</p>
<p>The trick for generating the first order approximation involves removing the third “level”
from the MPO form of H and multiplying with the appropriate factor of τ. This can be
visualised as follows</p>
<img alt="../_images/FirstOrderTrick.png" class="align-center" id="firstordertrick" src="../_images/FirstOrderTrick.png" />
<p>This method can be extended to any desired order in <span class="math notranslate nohighlight">\(\tau\)</span> as outlined in
<span id="id8">[<a class="reference internal" href="../References.html#id9" title="Maarten Van Damme, Jutho Haegeman, Ian McCulloch, and Laurens Vanderstraeten. Efficient higher-order matrix product operators for time evolution. 2023. arXiv:2302.14181.">Damme <em>et al.</em>, 2023</a>]</span>.</p>
</div>
<div class="section" id="imaginary-time-evolution">
<span id="imag-header"></span><h2><a class="toc-backref" href="#id14"><span class="section-number">12.3. </span>Imaginary Time Evolution</a><a class="headerlink" href="#imaginary-time-evolution" title="Permalink to this heading">#</a></h2>
<p>Besides simulating dynamics, any time evolution method can also be used to find the
groundstate of <span class="math notranslate nohighlight">\(\hat{H}\)</span> by taking <span class="math notranslate nohighlight">\(t\)</span> to be imaginary. The basis for this idea is the fact
that</p>
<div class="math notranslate nohighlight">
\[\ket{\Psi_0} = \lim_{\tau-&gt;+\infty} \frac{e^{-\tau \hat{H}} \ket{\Psi}}{\sqrt{\braket{\Psi|e^{-2\tau \hat{H}} |\Psi}}}\]</div>
<p>where <span class="math notranslate nohighlight">\(\ket{\Psi}\)</span> is any initial state not orthogonal to the ground state. Indeed expanding
the initial state in the eigenbasis of <span class="math notranslate nohighlight">\(\hat{H}\)</span> we have <span class="math notranslate nohighlight">\(\ket{\Psi} = \sum_i c_i \ket{E_i}\)</span>
with <span class="math notranslate nohighlight">\(\ket{E_i}\)</span> the eigenstate corresponding to energy <span class="math notranslate nohighlight">\(E_i\)</span> with ordering <span class="math notranslate nohighlight">\(E_0 &lt; E_1 &lt; E_2
&lt; \dots\)</span>. Then</p>
<div class="math notranslate nohighlight">
\[e^{-\tau \hat{H}} \ket{\Psi} = \sum_i c_i e^{-\tau E_i} \ket{E_i}\]</div>
<p>In taking the limit <span class="math notranslate nohighlight">\(\tau\to+\infty\)</span> the slowest vanishing exponential is that of <span class="math notranslate nohighlight">\(E_0\)</span>. In
this way the ground state gets projected out of the initial state. Demanding that the state
is normalized gives</p>
<div class="math notranslate nohighlight">
\[\lim_{\tau-&gt;+\infty} \frac{e^{-\tau \hat{H}} \ket{\Psi}}{\sqrt{\braket{\Psi|e^{-2\tau \hat{H}} |\Psi}}} = \lim_{\tau-&gt;+\infty} \frac{\sum_i c_i e^{-\tau E_i} \ket{E_i}}{\sqrt{\sum_i |c_i|^2 e^{-2\tau E_i}}} = \frac{c_0 }{|c_0|} \ket{E_0}\]</div>
<p>which gives the ground state up to an irrelevant phase factor.</p>
</div>
<div class="section" id="finite-temperature">
<span id="fintemp-header"></span><h2><a class="toc-backref" href="#id15"><span class="section-number">12.4. </span>Finite Temperature</a><a class="headerlink" href="#finite-temperature" title="Permalink to this heading">#</a></h2>
<p>It is possible to use time evolution methods to construct thermal density operators i.e.
<span class="math notranslate nohighlight">\(\rho = \frac{1}{Z}e^{-\beta \hat{H}}\)</span> with <span class="math notranslate nohighlight">\(\beta=1/T\)</span> and <span class="math notranslate nohighlight">\(Z\)</span> a normalization constant.
The idea here is to write <span class="math notranslate nohighlight">\(\rho\)</span> as an MPO</p>
<img alt="../_images/DensityMatrix.png" class="align-center" id="densitymatrix" src="../_images/DensityMatrix.png" />
<p>with the constraint that</p>
<img alt="../_images/Mconstraint.png" class="align-center" id="mconstraint" src="../_images/Mconstraint.png" />
<p>Here the triangles represent an isometry that fuses the two legs together into a bigger leg.
This particular form ensures that <span class="math notranslate nohighlight">\(\rho\)</span> is a positive semi-definite operator and thus
physical <span id="id9">[<a class="reference internal" href="../References.html#id10" title="F. Verstraete, J. J. Garc\'ıa-Ripoll, and J. I. Cirac. Matrix product density operators: simulation of finite-temperature and dissipative systems. Physical Review Letters, 93:207204, 2004. arXiv:cond-mat/0406426, doi:10.1103/PhysRevLett.93.207204.">Verstraete <em>et al.</em>, 2004</a>]</span>. Note that for <span class="math notranslate nohighlight">\(d_k=1\)</span> we obtain the density matrix of a
pure state. We can represent <span class="math notranslate nohighlight">\(\rho\)</span> as the density matrix of pure state (i.e. a MPS) by
introducing ancillas <span class="math notranslate nohighlight">\(\{\ket{a_k}\}\)</span> so that</p>
<img alt="../_images/AncillaMPS.png" class="align-center" id="ancillamps" src="../_images/AncillaMPS.png" />
<p>where the thicker physical legs indicate that they contain both the <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(a\)</span> degrees of
freedom. One immediately sees that <span class="math notranslate nohighlight">\(\rho=\text{Tr}_a({\ket{\Psi}\bra{\Psi}})\)</span>. The thermal
density operators <span class="math notranslate nohighlight">\(\rho(\beta)\)</span> for any <span class="math notranslate nohighlight">\(\beta\)</span> can then be found by starting from the
<span class="math notranslate nohighlight">\(\beta=0\)</span> state <span class="math notranslate nohighlight">\(\rho(0)=\mathbf{1}\)</span> and performing imaginary time evolution</p>
<div class="math notranslate nohighlight">
\[e^{-\beta H} = (e^{-\Delta \tau \hat{H}})^M\rho(0)(e^{-\Delta \tau \hat{H}})^M\]</div>
<p>with <span class="math notranslate nohighlight">\(\Delta \tau = \frac{\beta}{2M}\)</span> <span id="id10">[<a class="reference internal" href="../References.html#id10" title="F. Verstraete, J. J. Garc\'ıa-Ripoll, and J. I. Cirac. Matrix product density operators: simulation of finite-temperature and dissipative systems. Physical Review Letters, 93:207204, 2004. arXiv:cond-mat/0406426, doi:10.1103/PhysRevLett.93.207204.">Verstraete <em>et al.</em>, 2004</a>]</span>.</p>
</div>
<div class="section" id="code-example-mpskit-timestep-make-time-mpo">
<span id="code-header"></span><h2><a class="toc-backref" href="#id16"><span class="section-number">12.5. </span>Code Example: <code class="docutils literal notranslate"><span class="pre">MPSKit.timestep,make_time_mpo</span></code></a><a class="headerlink" href="#code-example-mpskit-timestep-make-time-mpo" title="Permalink to this heading">#</a></h2>
<p>Below is some code on how MPSKit and MPSKitModels can be used out-of-the-box to perform time
evolution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">TensorKit</span><span class="p">,</span><span class="n">MPSKit</span><span class="p">,</span><span class="n">MPSKitModels</span>
<span class="k">using</span><span class="w"> </span><span class="n">Plots</span>

<span class="n">H₀</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transverse_field_ising</span><span class="p">(;</span><span class="n">J</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="mf">0.0</span><span class="p">);</span>

<span class="c">#Create a MPS with physical bond dimension d=2 and virtual D=50 and optimize it</span>
<span class="n">Ψ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">InfiniteMPS</span><span class="p">([</span><span class="mi">2</span><span class="p">],[</span><span class="mi">50</span><span class="p">]);</span>
<span class="p">(</span><span class="n">gs</span><span class="p">,</span><span class="n">envs</span><span class="p">,</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_groundstate</span><span class="p">(</span><span class="n">Ψ</span><span class="p">,</span><span class="n">H₀</span><span class="p">,</span><span class="n">VUMPS</span><span class="p">(;</span><span class="n">verbose</span><span class="o">=</span><span class="nb">false</span><span class="p">));</span>

<span class="c">#Let&#39;s check some expectation values</span>
<span class="n">sz_gs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expectation_value</span><span class="p">(</span><span class="n">gs</span><span class="p">,</span><span class="n">σᶻ</span><span class="p">())</span><span class="w"> </span><span class="c"># we have found the |↑↑...↑&gt; or |↓↓...↓&gt; state</span>
<span class="n">E_gs</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">expectation_value</span><span class="p">(</span><span class="n">gs</span><span class="p">,</span><span class="n">H₀</span><span class="p">,</span><span class="n">envs</span><span class="p">)</span>

<span class="c"># time evolution Hamiltonian</span>
<span class="n">Ht</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">transverse_field_ising</span><span class="p">(;</span><span class="n">J</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="mf">0.25</span><span class="p">);</span>

<span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1</span>
<span class="n">Nsteps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span>
<span class="n">ts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">.*</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">Nsteps</span>

<span class="c">#Do the time evolution with tdvp</span>
<span class="n">sz_tdvp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="n">Nsteps</span><span class="p">);</span>
<span class="k">let</span><span class="w"> </span><span class="n">Ψt</span><span class="o">=</span><span class="n">gs</span><span class="p">,</span><span class="n">envs</span><span class="o">=</span><span class="n">environments</span><span class="p">(</span><span class="n">gs</span><span class="p">,</span><span class="n">Ht</span><span class="p">),</span><span class="n">alg</span><span class="o">=</span><span class="n">TDVP</span><span class="p">()</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">Nsteps</span>
<span class="w">    </span><span class="p">(</span><span class="n">Ψt</span><span class="p">,</span><span class="n">envs</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timestep</span><span class="p">(</span><span class="n">Ψt</span><span class="p">,</span><span class="n">Ht</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">alg</span><span class="p">,</span><span class="n">envs</span><span class="p">);</span>
<span class="w">    </span><span class="n">sz_tdvp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">real</span><span class="p">(</span><span class="n">expectation_value</span><span class="p">(</span><span class="n">Ψt</span><span class="p">,</span><span class="n">σᶻ</span><span class="p">())[</span><span class="mi">1</span><span class="p">])</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="c"># let&#39;s make a first order time evolution mpo out of Ht</span>
<span class="n">Ht_mpo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_time_mpo</span><span class="p">(</span><span class="n">Ht</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">,</span><span class="w"> </span><span class="kt">TaylorCluster</span><span class="p">{</span><span class="mi">1</span><span class="p">}());</span>

<span class="n">sz_tmpo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="n">Nsteps</span><span class="p">);</span>
<span class="k">let</span><span class="w"> </span><span class="n">Ψt</span><span class="o">=</span><span class="n">gs</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">Nsteps</span>
<span class="w">    </span><span class="n">Ψt</span><span class="p">,</span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">approximate</span><span class="p">(</span><span class="n">Ψt</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Ht_mpo</span><span class="p">,</span><span class="w"> </span><span class="n">Ψt</span><span class="p">),</span><span class="w"> </span><span class="n">VUMPS</span><span class="p">(;</span><span class="w"> </span><span class="n">verbose</span><span class="o">=</span><span class="nb">false</span><span class="p">));</span>
<span class="w">    </span><span class="n">sz_tmpo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">real</span><span class="p">(</span><span class="n">expectation_value</span><span class="p">(</span><span class="n">Ψt</span><span class="p">,</span><span class="n">σᶻ</span><span class="p">())[</span><span class="mi">1</span><span class="p">])</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="c"># let&#39;s make a 2nd order time evolution mpo out of Ht</span>
<span class="n">Ht_mpo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_time_mpo</span><span class="p">(</span><span class="n">Ht</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">,</span><span class="w"> </span><span class="kt">TaylorCluster</span><span class="p">{</span><span class="mi">2</span><span class="p">}());</span>

<span class="n">sz_tmpo2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="n">Nsteps</span><span class="p">);</span>
<span class="k">let</span><span class="w"> </span><span class="n">Ψt</span><span class="o">=</span><span class="n">gs</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">Nsteps</span>
<span class="w">    </span><span class="n">Ψt</span><span class="p">,</span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">approximate</span><span class="p">(</span><span class="n">Ψt</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Ht_mpo</span><span class="p">,</span><span class="w"> </span><span class="n">Ψt</span><span class="p">),</span><span class="w"> </span><span class="n">VUMPS</span><span class="p">(;</span><span class="w"> </span><span class="n">verbose</span><span class="o">=</span><span class="nb">false</span><span class="p">));</span>
<span class="w">    </span><span class="n">sz_tmpo2</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">real</span><span class="p">(</span><span class="n">expectation_value</span><span class="p">(</span><span class="n">Ψt</span><span class="p">,</span><span class="n">σᶻ</span><span class="p">())[</span><span class="mi">1</span><span class="p">])</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>

<span class="c"># Compare the different methods</span>
<span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plot</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s">&quot;t&quot;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s">&quot;&lt;σᶻ(t)&gt;&quot;</span><span class="p">);</span>
<span class="n">plot!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">ts</span><span class="p">,</span><span class="n">sz_tdvp</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">&quot;TDVP&quot;</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="ss">:black</span><span class="p">);</span>
<span class="n">scatter!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">ts</span><span class="p">,</span><span class="n">sz_tmpo</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">&quot;tmpo 1st&quot;</span><span class="p">);</span>
<span class="n">scatter!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">ts</span><span class="p">,</span><span class="n">sz_tmpo2</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">&quot;tmpo 2nd&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span><span class=" -Color -Color-Bold -Color-Bold-Cyan">[ Info: </span>Precompiling Plots [91a5bcdd-55d7-5caf-9e0b-520d859cae80]
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span><span class=" -Color -Color-Bold -Color-Bold-Cyan">[ Info: </span>Precompiling LogExpFunctionsChainRulesCoreExt [1bf5f11d-9a0a-5d25-85d0-d1d9a28a239c]
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span><span class=" -Color -Color-Bold -Color-Bold-Cyan">[ Info: </span>Precompiling LogExpFunctionsInverseFunctionsExt [1e5f9c58-a15c-5ce5-87cf-a68a2eda25d9]
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span><span class=" -Color -Color-Bold -Color-Bold-Cyan">[ Info: </span>Precompiling IJuliaExt [2f4121a4-3b3a-5ce6-9c5e-1f2673ce168a]
</pre></div>
</div>
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="ne">InterruptException</span>:

<span class="ne">Stacktrace</span>:
 <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">top</span><span class="o">-</span><span class="n">level</span> <span class="n">scope</span>
   <span class="o">@</span> <span class="n">In</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mi">31</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="c"># We can also find the groundstate using imaginary time evolution</span>
<span class="n">H</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">transverse_field_ising</span><span class="p">(;</span><span class="n">J</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="mf">0.35</span><span class="p">);</span>

<span class="n">Ψ</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">InfiniteMPS</span><span class="p">([</span><span class="mi">2</span><span class="p">],[</span><span class="mi">50</span><span class="p">]);</span><span class="w"> </span><span class="c">#random MPS</span>
<span class="n">Ψenv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">environments</span><span class="p">(</span><span class="n">Ψ</span><span class="p">,</span><span class="n">H</span><span class="p">)</span><span class="w"> </span><span class="p">;</span>
<span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1</span><span class="p">;</span>
<span class="n">Es</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
<span class="n">Es</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">real</span><span class="p">(</span><span class="n">expectation_value</span><span class="p">(</span><span class="n">Ψ</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">envs</span><span class="p">)[</span><span class="mi">1</span><span class="p">]);</span>
<span class="k">for</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="mi">50</span>
<span class="w">    </span><span class="p">(</span><span class="n">Ψ</span><span class="p">,</span><span class="n">Ψenv</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timestep</span><span class="p">(</span><span class="n">Ψ</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="nb">im</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span><span class="n">TDVP</span><span class="p">(),</span><span class="n">Ψenv</span><span class="p">)</span>
<span class="w">    </span><span class="n">Es</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">real</span><span class="p">(</span><span class="n">expectation_value</span><span class="p">(</span><span class="n">Ψ</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">Ψenv</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">end</span>

<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plot</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s">&quot;iter&quot;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s">&quot;&lt;H&gt;&quot;</span><span class="p">);</span>
<span class="n">hline!</span><span class="p">([</span><span class="o">-</span><span class="mf">1.030867019</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="s">&quot;Exact solution&quot;</span><span class="p">)</span>
<span class="n">scatter!</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">Es</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "julia-1.9"
        },
        kernelOptions: {
            name: "julia-1.9",
            path: "./3-Algorithms"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'julia-1.9'</script>

                    </div>
                    
                </main> <!-- .page__content -->
                


                <footer class="qe-page__footer">

                    <p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://licensebuttons.net/l/by-sa/4.0/80x15.png"></a></p>

                    <p>Creative Commons License &ndash; This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International.</p>

                </footer> <!-- .page__footer -->

            </div> <!-- .page -->

            

            
            <div class="qe-sidebar bd-sidebar inactive" id="site-navigation">

                <div class="qe-sidebar__header">


                    Contents

                </div>

                <nav class="qe-sidebar__nav" id="qe-sidebar-nav" aria-label="Main navigation">
                    <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../1-Introduction/QuantumManyBody.html">
   1. Quantum Many-Body Physics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1-Introduction/Software.html">
   2. Getting Started with Numerics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1-Introduction/LinearAlgebra.html">
   3. (Multi-) Linear Algebra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1-Introduction/TensorNetworks.html">
   4. Tensor Network Theory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1-Introduction/Symmetries.html">
   5. Symmetries in Quantum Many-Body Physics
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Matrix Product States
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../2-MatrixProductStates/MatrixProductStates.html">
   6. Matrix Product States
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../2-MatrixProductStates/InfiniteMPS.html">
   7. Infinite Matrix Product States
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../2-MatrixProductStates/Algorithms.html">
   8. Tensor Network Algorithms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../2-MatrixProductStates/MatrixProductOperators.html">
   9. Matrix Product Operators
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../2-MatrixProductStates/Applications.html">
   10. Applications
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Tensor Network Algorithms
 </span>
</p>
<ul class="current nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="FixedpointAlgorithms.html">
   11. Fixed-Point algorithms
  </a>
 </li>
 <li class="toctree-l1 current active active">
  <a class="current reference internal" href="#">
   12. Time Evolution
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Other
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../References.html">
   13. References
  </a>
 </li>
</ul>

                </nav>

                <div class="qe-sidebar__footer">

                </div>

            </div> <!-- .sidebar -->
            
        </div> <!-- .main -->

        <div class="qe-toolbar">

            <div class="qe-toolbar__inner">

                <ul class="qe-toolbar__main">
                    <li data-tippy-content="Table of Contents" class="btn__sidebar"><i data-feather="menu"></i></li>
                    <li data-tippy-content="Home"><a href="../intro.html"><i data-feather="home"></i></a></li>
                    <li><a href="https://quantumghent.github.io/" title="">QuantumGroup@UGent</a></li>
                    <li><a href="https://github.com/quantumghent/" title="GitHub" rel="external nofollow noopener" target="_blank"><i class="fab fa-github"></i></a></li>
                </ul>

                <ul class="qe-toolbar__links">
                    <li class="btn__search">
                        <form action="../search.html" method="get">
                            <input type="search" class="form-control" name="q" id="search-input" placeholder="Search..." aria-label="Search..." autocomplete="off" accesskey="k">
                            <i data-feather="search" id="search-icon"></i>
                        </form>
                    </li>
                    <li data-tippy-content="Fullscreen" class="btn__fullscreen"><i data-feather="maximize"></i></li>
                    <li data-tippy-content="Increase font size" class="btn__plus"><i data-feather="plus-circle"></i></li>
                    <li data-tippy-content="Decrease font size" class="btn__minus"><i data-feather="minus-circle"></i></li>
                    <li data-tippy-content="Change contrast" class="btn__contrast"><i data-feather="sunset"></i></li>
                    <li class="settings-button" id="settingsButton"><div data-tippy-content="Launch Notebook"><i data-feather="play-circle"></i></div></li>
                        <li data-tippy-content="Download PDF" onClick="window.print()"><i data-feather="file"></i></li>
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/quantumghent/TensorTutorials//blob/main/lectures/3-Algorithms/TimeEvolutionAlgorithms.md" download><i data-feather="github"></i></a></li>
                </ul>

            </div>

        </div> <!-- .toolbar -->
        <div id="downloadPDFModal" style="display: none;">
            <ul class="pdf-options" style="display: block;">
                <li class="download-pdf-book" onClick="window.print()">
                    <p>Lecture (PDF)</p>
                </li>
                <li class="download-pdf-file">
                    <a href="" download><p>Book (PDF)</p></a>
                </li>
            </ul>
        </div>
        <div id="settingsModal" style="display: none;">
            <p class="modal-title"> Notebook Launcher </p>
            <div class="modal-desc">
            <p>
                Choose public or private cloud service for "Launch" button.
            </p>
            </div>
            <p class="modal-subtitle">Select a server</p>
            <ul class="modal-servers">
            <li class="active launcher-public">
                <span class="label">Public</span>
                <select id="launcher-public-input">
                
                    <option value="https://colab.research.google.com/github/quantumghent/TensorTutorials.notebooks/blob/main/3-Algorithms/TimeEvolutionAlgorithms.ipynb">Colab</option>
                
                </select>
                <i class="fas fa-check-circle"></i>
            </li>
            <li class="launcher-private">
                <span class="label">Private</span>
                <input type="text" id="launcher-private-input" data-repourl="https://github.com/quantumghent/TensorTutorials.notebooks/" data-urlpath="tree/TensorTutorials.notebooks/3-Algorithms/TimeEvolutionAlgorithms.ipynb" data-branch=main>
                <i class="fas fa-check-circle"></i>
            </li>
            </ul>
            <p class="launch"><a href="https://colab.research.google.com/github/quantumghent/TensorTutorials.notebooks/blob/main/3-Algorithms/TimeEvolutionAlgorithms.ipynb" id="advancedLaunchButton" target="_blank">Launch Notebook</a></p>
            <script>
                // QuantEcon Notebook Launcher
                const launcherTypeElements = document.querySelectorAll('#settingsModal .modal-servers li');
                // Highlight the server type if previous selection exists
                if (typeof localStorage.launcherType !== 'undefined') {
                  for (var i = 0; i < launcherTypeElements.length; i++) {
                    launcherTypeElements[i].classList.remove('active');
                    if ( launcherTypeElements[i].classList.contains(localStorage.launcherType) ) {
                      launcherTypeElements[i].classList.add('active');
                    }
                  }
                }
                // Highlight server type on click and set local storage value
                for (var i = 0; i < launcherTypeElements.length; i++) {
                  launcherTypeElements[i].addEventListener('click', function() {
                    for (var j = 0; j < launcherTypeElements.length; j++) {
                      launcherTypeElements[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    if ( this.classList.contains('launcher-private') ) {
                      localStorage.launcherType = 'launcher-private';
                    } else if ( this.classList.contains('launcher-public') ) {
                      localStorage.launcherType = 'launcher-public';
                    }
                    setLaunchServer();
                  })
                }
                const launcherPublic = document.getElementById('launcher-public-input');
                const launcherPrivate = document.getElementById('launcher-private-input');
                const pageName = "3-Algorithms/TimeEvolutionAlgorithms";
                const repoURL = "https://github.com/quantumghent/TensorTutorials.notebooks/";
                const urlPath = "tree/TensorTutorials.notebooks/3-Algorithms/TimeEvolutionAlgorithms.ipynb";
                const branch = "main"
                const launchNotebookLink = document.getElementById('advancedLaunchButton');

                // Highlight public server option if previous selection exists
                if (typeof localStorage.launcherPublic !== 'undefined') {
                  launcherPublic.value = localStorage.launcherPublic;
                }
                // Update local storage upon public server selection
                launcherPublic.addEventListener('change', (event) => {
                  setLaunchServer();
                });
                // Populate private server input if previous entry exists
                if (typeof localStorage.launcherPrivate !== 'undefined') {
                  launcherPrivate.value = localStorage.launcherPrivate;
                }
                // Update local storage when a private server is entered
                launcherPrivate.addEventListener('input', (event) => {
                  setLaunchServer();
                });

                // Function to update the "Launch Notebook" link href
                function setLaunchServer() {
                  launchNotebookLink.removeAttribute("style")
                  if ( localStorage.launcherType == 'launcher-private' ) {
                    let repoPrefix = "/jupyter/hub/user-redirect/git-pull?repo=" + repoURL + "&branch=" + branch + "&urlpath=" + urlPath;
                    launcherPrivateValue = launcherPrivate.value
                    if (!launcherPrivateValue) {
                        launchNotebookLink.removeAttribute("href")
                        launchNotebookLink.style.background = "grey"
                        return
                    }
                    localStorage.launcherPrivate = launcherPrivateValue;
                    privateServer = localStorage.launcherPrivate.replace(/\/$/, "")
                    if (!privateServer.includes("http")) {
                        privateServer = "http://" + privateServer
                    }
                    launchNotebookLinkURL = privateServer + repoPrefix;
                  } else if ( localStorage.launcherType == 'launcher-public' ) {
                    launcherPublicValue = launcherPublic.options[launcherPublic.selectedIndex].value;
                    localStorage.launcherPublic = launcherPublicValue;
                    launchNotebookLinkURL = localStorage.launcherPublic;
                  }
                  if (launchNotebookLinkURL) launchNotebookLink.href = launchNotebookLinkURL;
                }
                // Check if user has previously selected a server
                if ( (typeof localStorage.launcherPrivate !== 'undefined') || (typeof localStorage.launcherPublic !== 'undefined') ) {
                  setLaunchServer();
                }
                </script>

        </div>

    </div> <!-- .wrapper-->
  </body>
</html>