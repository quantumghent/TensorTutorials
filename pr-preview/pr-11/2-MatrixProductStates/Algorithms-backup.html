



<!DOCTYPE html>


<html lang="en" data-theme="light 
">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tensor Network Algorithms &#8212; TensorTutorials</title>
    
    <script src="https://unpkg.com/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6.3.1/dist/tippy-bundle.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    
        <script>
            MathJax = {
            loader: {load: ['[tex]/boldsymbol', '[tex]/textmacros']},
            tex: {
                packages: {'[+]': ['boldsymbol', 'textmacros']},
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                processEscapes: true,
                macros: {
                    "argmax" : "arg\\,max",
                    "argmin" : "arg\\,min",
                    "col"    : "col",
                    "Span"   :  "span",
                    "epsilon": "\\varepsilon",
                    "EE": "\\mathbb{E}",
                    "PP": "\\mathbb{P}",
                    "RR": "\\mathbb{R}",
                    "NN": "\\mathbb{N}",
                    "ZZ": "\\mathbb{Z}",
                    "aA": "\\mathcal{A}",
                    "bB": "\\mathcal{B}",
                    "cC": "\\mathcal{C}",
                    "dD": "\\mathcal{D}",
                    "eE": "\\mathcal{E}",
                    "fF": "\\mathcal{F}",
                    "gG": "\\mathcal{G}",
                    "hH": "\\mathcal{H}",
                }
            },
            svg: {
                fontCache: 'global',
                scale: 0.92,
                displayAlign: "center",
            },
            };
        </script>
    
    
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light 
";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=927b94d3fcb96560df09" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=927b94d3fcb96560df09" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=927b94d3fcb96560df09" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=927b94d3fcb96560df09" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/quantumghent-book-theme.5e19e0a6c2e2247c14aaae6dbdd37c4f.css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=927b94d3fcb96560df09" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=927b94d3fcb96560df09" />
  <script src="../_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=927b94d3fcb96560df09"></script>


    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script src="../_static/quantumghent-book-theme.ef2ef6c3e8da75e1e736fb5fce08cde6.js"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-3PCWRLGWND"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-3PCWRLGWND');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"argmax": "arg\\,max", "argmin": "arg\\,min"}, "packages": {"[+]": ["physics"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '2-MatrixProductStates/Algorithms-backup';</script>
    <link rel="canonical" href="https://quantumghent.github.io/TensorTutorials/2-MatrixProductStates/Algorithms-backup.html" />
    <link rel="shortcut icon" href="../_static/lectures-favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />

<!-- Normal Meta Tags -->
<meta name="author" context="Jacob Bridgeman, Lander Burgelman, Lukas Devos, Jutho Haegeman, Daan Maertens, Bram Vancraeynest-De Cuiper and Kevin Vervoort" />
<meta name="keywords" content="Julia, Tensor Networks, Quantum Many-Body Physics, Statistical Mechanics" />
<meta name="description" content=This website presents a set of lectures on Tensor Network methods />

<!-- Twitter tags -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@" />
<meta name="twitter:title" content="Tensor Network Algorithms"/>
<meta name="twitter:description" content="This website presents a set of lectures on Tensor Network methods">
<meta name="twitter:creator" content="@">
<meta name="twitter:image" content="">

<!-- Opengraph tags -->
<meta property="og:title" content="Tensor Network Algorithms" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://quantumghent.github.io/TensorTutorials/2-MatrixProductStates/Algorithms-backup.html" />
<meta property="og:image" content="" />
<meta property="og:description" content="This website presents a set of lectures on Tensor Network methods" />
<meta property="og:site_name" content="TensorTutorials" />
<meta name="theme-color" content="#ffffff" />

  </head>
<body>


    <span id="top"></span>

    <div class="qe-wrapper">

        <div class="qe-main">

            <div class="qe-page" id=2-MatrixProductStates/Algorithms-backup>

                <div class="qe-page__toc">

                    <div class="inner">

                        
                        <div class="qe-page__toc-header">
                            On this page
                        </div>


                        <nav id="bd-toc-nav" class="qe-page__toc-nav">
                            <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#simulating-quantum-systems">Simulating Quantum Systems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#classical-statistical-mechanics">Classical Statistical Mechanics</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#case-study-tebd">Case Study: TEBD</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#approximating-the-time-evolution-operator">Approximating The Time Evolution Operator</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#simulating-a-one-dimensional-system">Simulating a One-Dimensional System</a></li>
</ul>
</li>
</ul>
                            <p class="logo">
                                
                                    
                                    <a href=https://quantumghent.github.io/><img src="../_static/logo.png" class="logo" alt="logo"></a>
                                    
                                
                            </p>

                            <p class="powered">Powered by <a href="https://jupyterbook.org/">Jupyter Book</a></p>

                        </nav>

                        <div class="qe-page__toc-footer">
                            
                            
                            <p><a href="#top"><strong>Back to top</strong></a></p>
                        </div>

                    </div>

                </div>

                <div class="qe-page__header">

                    <div class="qe-page__header-copy">

                        <p class="qe-page__header-heading"><a href="../intro.html">TensorTutorials</a></p>

                        <p class="qe-page__header-subheading">Tensor Network Algorithms</p>

                    </div>

                    <p class="qe-page__header-authors">Jacob Bridgeman, Lander Burgelman, Lukas Devos, Jutho Haegeman, Daan Maertens, Bram Vancraeynest-De Cuiper and Kevin Vervoort</p>

                </div> <!-- .page__header -->



                
                <main class="qe-page__content" role="main">
                    
                    <div>
                        
  <div class="tex2jax_ignore mathjax_ignore section" id="tensor-network-algorithms">
<h1>Tensor Network Algorithms<a class="headerlink" href="#tensor-network-algorithms" title="Permalink to this heading">#</a></h1>
<p>Now that we have introduced tensor networks in general and have spent some time on the
particular case of MPS in one spatial dimension, it is worth to consider some possible
applications of this tensor-network framework. While there are a large number of theoretical
results in quantum many body physics based on tensor networks, for example the
characterization of (symmetry-protected) topological order in one- and two-dimensional
quantum systems, here we will focus more on algorithmic and numerical aspects. In this
section we will give a general introduction to the kind of problems that can be tackled
using tensor-network simulations and discuss an approach to simulating dynamics in a
one-dimensional quantum system as an illustrative example.</p>
<div class="section" id="simulating-quantum-systems">
<h2>Simulating Quantum Systems<a class="headerlink" href="#simulating-quantum-systems" title="Permalink to this heading">#</a></h2>
<!-- TODO: decide how much of the general introduction we want to keep; maybe even move some things up since we've already mentioned for example expectation values, so it's a bit silly to introduce these here again... -->
<p>A first setting where tensor network methods have been intensively applied is that of
simulating quantum systems. . We will introduce these algorithms in the setting of discrete
spin systems. Consider a system in which physical spins with a local Hilbert space <span class="math notranslate nohighlight">\(
\mathcal H_\lambda = \mathbb C^d \)</span> of dimension <span class="math notranslate nohighlight">\( d \)</span> are located at every site <span class="math notranslate nohighlight">\( \lambda \)</span>
of some lattice <span class="math notranslate nohighlight">\( \Lambda \)</span>, giving rise to a total Hilbert space of the system <span class="math notranslate nohighlight">\( \mathcal H
= \bigotimes_{\lambda \in \Lambda} \mathcal H_\lambda = \left( \mathbb C^d \right)^{\otimes
N}\)</span> where <span class="math notranslate nohighlight">\( N = |\Lambda| \)</span> is the total number of sites in the lattice (see
Fig.~\ref{fig:lattice}). Such a lattice system of spins naturally translates to the setting
of tensor networks where each local Hilbert space then corresponds to a physical index of
the lattice, and where the network geometry is (usually) chosen to reflect that of the
original lattice.</p>
<a class="reference internal image-reference" href="../_images/lattice.svg" id="lattice"><img alt="../_images/lattice.svg" class="align-center" height="216" id="lattice" src="../_images/lattice.svg" width="220" /></a>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While we will systematically work in the setting of discrete spin systems, tensor networks
can also be applied to the study of continious systems such as quantum field theories. This
is usually done by either cleverly discretizing the continious system into a form that is
amenable to a tensor network description (References?), or by adapting the network ansatz
itself to reflect the continuous nature of the system (CMPS/CTNS references?).</p>
</div>
<p>To characterize the properties of a given system we will generally be interested in
<em>measuring observables</em>. This can for example be the expectation value of a local operator <span class="math notranslate nohighlight">\(
O_\lambda \)</span> acting on site <span class="math notranslate nohighlight">\( \lambda \)</span>,</p>
<div class="math notranslate nohighlight">
\[\langle O_\lambda \rangle = {\rm tr}(O_\lambda \rho),\]</div>
<p>or a (connected) correlation function of local observables,</p>
<div class="math notranslate nohighlight">
\[\langle O_\lambda O_\mu \rangle - \langle O_\lambda \rangle \langle O_\mu \rangle.\]</div>
<p>A particularly important observable for quantum systems is the <em>Hamiltonian</em>. The
Hamiltonian of a given system serves two important purposes. On the one hand it dictates the
dynamics of the system, i.e., how the state of the system changes as time passes. On the
other hand it governs the thermal equilibrium of the system if the system is coupled to an
external environment. For our discussion here we will consider <em>local Hamiltonians</em> of the
form</p>
<div class="math notranslate nohighlight" id="equation-localham">
<span class="eqno">()<a class="headerlink" href="#equation-localham" title="Permalink to this equation">#</a></span>\[H = \sum_{s \in \Lambda} h_s\]</div>
<p>where each <span class="math notranslate nohighlight">\( h_s \)</span> is <em>geometrically local</em>, meaning that it acts on a connected subregion <span class="math notranslate nohighlight">\(
s \)</span> of the lattice <span class="math notranslate nohighlight">\( \Lambda \)</span> whose size <span class="math notranslate nohighlight">\( |s| \leq k \)</span> is bounded by some constant <span class="math notranslate nohighlight">\( k \)</span>
and does not scale with the system size. For example, terms with <span class="math notranslate nohighlight">\( |s| = 1 \)</span> act on a single
lattice site, while terms with <span class="math notranslate nohighlight">\( |s| = 2 \)</span> act on neighboring lattice sites and are called
<em>nearest neighbor interactions</em>. Aside from microscopic relativistic theories where locality
is guaranteed, it turns out that many condensed matter many-body systems are described be a
local effective Hamiltonian at relevant renormalized scales. Therefore, the simulation of
local Hamiltonians is a highly relevant problem.</p>
<!-- TODO: uniformize model definitions, or just drop them altogether? -->
<!-- You might already be familiar with some basic lattice spin models with local interactions, such as the one-dimensional Ising model
```{math}
:label: ising
	H = \sum_{i=1}^{N} \sigma_{i}^{z} \sigma_{i+1}^{z} + h_x \sum_{i=1}^{N} \sigma_{i}^{x}
```
or the two-dimensional Heisenberg model
```{math}
	H = \sum_{\langle \lambda, \mu \rangle} \left( \sigma_x^{(\lambda)} \sigma_x^{(\mu)} + \sigma_y^{(\lambda)} \sigma_y^{(\mu)} + \sigma_z^{(\lambda)} \sigma_z^{(\mu)} \right)
```
which capture some magnetic properties of spin systems. Another important example is the so-called \emph{Hubbard model}, which is a model of interacting fermionic particles with the Hamiltonian
```{math}
	H = -\sum_{\langle \lambda, \mu \rangle} \sum_{\sigma \in \{\uparrow, \downarrow\}} a_{\sigma}^{\dagger(\lambda)} a_{\sigma}^{(\mu)} + \frac{u}{2} \sum_{\lambda} a_{\uparrow}^{\dagger (\lambda)} a_{\uparrow}^{(\lambda)} a_{\downarrow}^{\dagger (\lambda)} a_{\downarrow}^{(\lambda)},
```
where $ a $ are fermionic creation/annihilation operators with appropriate commutations relations. Note that all examples given here are have at most nearest neighbor interactions with $ |s| = 2 $. -->
<!-- settings for simulating quantum systems -->
<p>Generally speaking, there are three classes of problems one might wish to tackle within the
simulation of qantum systems:</p>
<ol class="arabic">
<li><p><strong>Dynamics</strong>: Consider a lattice <span class="math notranslate nohighlight">\( \Lambda \)</span> hosting some number of spins <span class="math notranslate nohighlight">\( N \)</span> which
interact according to a given Hamiltonian\footnote{In our discussion we will assume that
the Hamiltonian is time-independent. However, the simulation protocols described here
work just as well for time-dependent Hamiltonians.} <span class="math notranslate nohighlight">\( H \)</span>, and some observable <span class="math notranslate nohighlight">\( O \)</span> in
which we are interested. Given an initial state <span class="math notranslate nohighlight">\( \ket{\psi_0} \)</span> which is easy to prepare
(for example a product state), we now want to estimate the expectation value of this
operator after a time <span class="math notranslate nohighlight">\( t \)</span> up to some desired precision <span class="math notranslate nohighlight">\( \varepsilon \)</span>. What we want is
to find a procedure to obtain an estimate <span class="math notranslate nohighlight">\( O_{\text{out}} \)</span> such that</p>
<div class="math notranslate nohighlight">
\[| O_{\text{out}} - \langle \psi(t)|O|\psi(t) \rangle | &lt; \varepsilon,\]</div>
<p>where <span class="math notranslate nohighlight">\( \ket{\psi(t)} \)</span> is the <em>time-evolved state</em> <span class="math notranslate nohighlight">\( \ket{\psi(t)} = e^{-i H t}
\ket{\psi_0} \)</span>.</p>
</li>
<li><p><strong>Ground state preparation</strong>: Consider the same setting as in the case of dynamics, but
where we now want to estimate the <em>ground state</em> of <span class="math notranslate nohighlight">\( H \)</span>, which is defined as the
eigenstate <span class="math notranslate nohighlight">\( \ket{E_0} \)</span>, <span class="math notranslate nohighlight">\( H \ket{E_0} = E_0 \ket{E_0} \)</span>, with the lowest energy <span class="math notranslate nohighlight">\( E_0
\)</span>. That is, we want to find a procedure to obtain an estimate <span class="math notranslate nohighlight">\( O_{\text{out}} \)</span> for the
expectation value of any observable <span class="math notranslate nohighlight">\( O \)</span> such that</p>
<div class="math notranslate nohighlight">
\[| O_{\text{out}} - \langle E_0|O|E_0 \rangle | &lt; \varepsilon.\]</div>
</li>
<li><p><strong>Thermal equilibrium</strong>: Consider the same setup as above, but where we couple our system
to an environment at some given temperature <span class="math notranslate nohighlight">\( T \)</span>. We now want to estimate the <em>thermal
state</em> <span class="math notranslate nohighlight">\( \rho \)</span> which corresponds to the mixed state density operator of the system once
it has reached thermal equilibrium with the environment. That is, we want to find a
procedure to obtain an estimate <span class="math notranslate nohighlight">\( O_{\text{out}} \)</span> for the expectation value of any
observable <span class="math notranslate nohighlight">\( O \)</span> such that</p>
<div class="math notranslate nohighlight">
\[| O_{\text{out}} - {\rm tr}(O \rho) | &lt; \varepsilon\]</div>
<p>where <span class="math notranslate nohighlight">\( \rho = \frac{e^{-\beta H}}{\mathcal Z} \)</span>, <span class="math notranslate nohighlight">\( \beta = 1/T \)</span> and <span class="math notranslate nohighlight">\( \mathcal Z = {\rm
tr} e^{-\beta H} \)</span>.</p>
</li>
</ol>
<p>For each of these settings a number of tensor network techniques have been developed which
each have their strengths and drawbacks depending on the specific problem under study.</p>
<div class="admonition-todo admonition">
<p class="admonition-title">TODO</p>
<p>Give an overview of (common) algorithms for tacking these problems and add references. Can
this be done relatively succunctly? E.g. DMRG, TEBD, VUMPS, gradient methods, …</p>
</div>
</div>
<div class="section" id="classical-statistical-mechanics">
<h2>Classical Statistical Mechanics<a class="headerlink" href="#classical-statistical-mechanics" title="Permalink to this heading">#</a></h2>
<p>A second area where tensor networks have proven very effective in that of classical
statistical mechanics. The central object in this setting is the <em>partition</em> function,
<span class="math notranslate nohighlight">\(\mathcal Z\)</span>, which encodes the properties of some statistical ensemble that we wich to
analyze. This setting is intricately linked to that of quantum systems, in the sense that a
quantum system with a Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> can always be mapped to a classical statistical system
in one spatial dimension higher, whose partition function is then defined as</p>
<div class="math notranslate nohighlight">
\[\mathcal Z = {\rm tr} \text{e}^{-\beta H}.\]</div>
<p>For this reason, tensor network techniques for statistical mechanics often closely resemble
those used in the study of quantum systems in one fewer spatial dimensions. One can of
course also directly study statistical ensembles in their own right. For a classical spin
system with Hamiltonian <span class="math notranslate nohighlight">\(H\)</span>, the corresponding partition function is defined as</p>
<div class="math notranslate nohighlight">
\[\mathcal Z = \sum_{\{s_i\}} \text{e}^{-\beta H({\{s_i\}})},\]</div>
<p>where the sum runs over all possible configurations of the spins <span class="math notranslate nohighlight">\(s_i\)</span>.</p>
<p>In either setting, the partition function can be rewritten as the contraction of a tensor
network, which for example in two dimensions looks something like</p>
<a class="reference internal image-reference" href="_static/figures/alg/partition_function.svg" id="partfunc"><img alt="_static/figures/alg/partition_function.svg" class="align-center" id="partfunc" src="_static/figures/alg/partition_function.svg" /></a>
<p>Here, the local tensors encode the statistical weights and contracting the network
corresponds to summing over all possible configurations of the spins which are automatically
assigned the appropriate weight.</p>
<p>Since contraction a general network cannot be done efficiently, evaluating the partition
function in this way requires approximate contraction techniques. In the case of two
dimensions, one can for example resort to <em>boundary MPS techniques</em>
<span id="id1">[<a class="reference internal" href="../References.html#id9" title="V. Zauner-Stauber, L. Vanderstraeten, M. T. Fishman, F. Verstraete, and J. Haegeman. Variational optimization algorithms for uniform matrix product states. Physical Review B, 97(4):045145, January 2018. URL: http://arxiv.org/abs/1701.07035, arXiv:1701.07035, doi:10.1103/PhysRevB.97.045145.">ZaunerStauberVF+18</a>]</span>, where the network contraction is performed by finding
the MPS fixed point of its row-to-row transfer matrix,</p>
<a class="reference internal image-reference" href="../_images/boundary_mps.svg" id="boundary-mps"><img alt="../_images/boundary_mps.svg" class="align-center" height="161" id="boundary-mps" src="../_images/boundary_mps.svg" width="616" /></a>
<p>which can then be pulled throught the entire system to evaluate the parititon function.
Alternatively, one can approximate the environments of a local patch in terms of environment
tensors,</p>
<a class="reference internal image-reference" href="../_images/ctmrg.svg" id="ctmrg"><img alt="../_images/ctmrg.svg" class="align-center" height="359" id="ctmrg" src="../_images/ctmrg.svg" width="591" /></a>
<p>by means of the Corner Transfer Matrix Renormalization Group (CTMRG) technique
<span id="id2">[<a class="reference internal" href="../References.html#id10" title="T. Nishino and K. Okunishi. Corner Transfer Matrix Renormalization Group Method. Journal of the Physical Society of Japan, 65(4):891–894, April 1996. URL: http://arxiv.org/abs/cond-mat/9507087, arXiv:cond-mat/9507087, doi:10.1143/JPSJ.65.891.">NO96</a>]</span>.</p>
<div class="admonition-todo admonition">
<p class="admonition-title">TODO</p>
<p>Anything more to say on this? Does it even make sense to discuss this here in the first
place?</p>
</div>
<p>(tebd) =</p>
</div>
<div class="section" id="case-study-tebd">
<h2>Case Study: TEBD<a class="headerlink" href="#case-study-tebd" title="Permalink to this heading">#</a></h2>
<p>As a basic illustrative example of a tensor network application we will discuss the Time
Evolving Block Decimation (TEBD) algorithm for simulating time evolution of one-dimensional
quantum systems <span id="id3">[<a class="reference internal" href="../References.html#id12" title="Guifre Vidal. Efficient classical simulation of slightly entangled quantum computations. Physical Review Letters, 91(14):147902, October 2003. URL: http://arxiv.org/abs/quant-ph/0301063, arXiv:quant-ph/0301063, doi:10.1103/PhysRevLett.91.147902.">Vid03</a>]</span>. To this end we first discuss a well known method
for approximating the time evolution operator based on the Suzuki-Trotter decomposition.</p>
<div class="section" id="approximating-the-time-evolution-operator">
<h3>Approximating The Time Evolution Operator<a class="headerlink" href="#approximating-the-time-evolution-operator" title="Permalink to this heading">#</a></h3>
<p>In order to simulate quantum dynamics, we want to design a protocol for reliably estimating
any expectation value <span class="math notranslate nohighlight">\( O_{\text{out}} \)</span> for a time-evolved state starting from an initial
state <span class="math notranslate nohighlight">\( \ket{\psi(0)} = \ket{\psi_0} \)</span>,</p>
<div class="math notranslate nohighlight">
\[	| O_{\text{out}} - \langle\psi(t)|O|\psi(t)\rangle | &lt; \varepsilon.\]</div>
<p>We can achieve this by directly preparing the time-evolved state which approximates a
solution of Schrödinger’s equation,</p>
<div class="math notranslate nohighlight" id="equation-time-evo">
<span class="eqno">()<a class="headerlink" href="#equation-time-evo" title="Permalink to this equation">#</a></span>\[	\ket{\psi(t)} = e^{-i H t} \ket{\psi(0)}.\]</div>
<p>after which we can simply measure <span class="math notranslate nohighlight">\( O \)</span> in resulting state. Directly exponentiating the full
Hamiltonian is of course entirely intractable for larger system sizes, but we can exploit
the structure of the system to find a suitable approximation up to a given order. The
important point is that although <span class="math notranslate nohighlight">\( e^{-i H t} \)</span> is difficult to compute, each <span class="math notranslate nohighlight">\( e^{-i h_s t}
\)</span> on the other hand acts only on a much smaller subsystem and can therefore be evaluated
efficiently. The problem however is that we cannot simply apply each <span class="math notranslate nohighlight">\( e^{-i h_s t} \)</span>
individually, since in general <span class="math notranslate nohighlight">\( e^{-i H t} \ne \prod_{s \in \Lambda} e^{-i h_s t} \)</span> since
the individual terms in the Hamiltonian don’t necessarily commute. Still, we will be able to
construct a reasonable approximation to <span class="math notranslate nohighlight">\( e^{-i H t} \)</span> using only the local gates <span class="math notranslate nohighlight">\( e^{-i
h_s t} \)</span>.</p>
<p>One way to do this is by relying on the <em>first order Suzuki-Trotter decomposition</em>, which
states that for any two Hermitian operators <span class="math notranslate nohighlight">\( A \)</span> and <span class="math notranslate nohighlight">\( B \)</span>, and any real <span class="math notranslate nohighlight">\(\Delta t\)</span>,</p>
<div class="math notranslate nohighlight" id="equation-trotter-first">
<span class="eqno">()<a class="headerlink" href="#equation-trotter-first" title="Permalink to this equation">#</a></span>\[e^{(A + B) \Delta t} = e^{A \Delta t} e^{B \Delta t} + \mathcal O(\Delta t^2).\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There actually exis tentire families of such exponential product approximations up to a
given order <span id="id4">[<a class="reference internal" href="../References.html#id11">HS05</a>]</span>. For our purposes however, it is sufficient to
illustrate a simulation procedure using this first-order approximation.</p>
</div>
</div>
<div class="section" id="simulating-a-one-dimensional-system">
<h3>Simulating a One-Dimensional System<a class="headerlink" href="#simulating-a-one-dimensional-system" title="Permalink to this heading">#</a></h3>
<p>We can put the discussion above into practice by applying it to the example of a
nearest-neighbor Hamiltonian in one dimension,</p>
<div class="math notranslate nohighlight" id="equation-1dham">
<span class="eqno">()<a class="headerlink" href="#equation-1dham" title="Permalink to this equation">#</a></span>\[	H = \sum_{n = 1}^{N} h_{(n, n+1)},\]</div>
<p>where we assume periodic boundary conditions <span class="math notranslate nohighlight">\( N + 1 \to 1 \)</span>. We now want to simulate the
dynamics of this Hamiltonian in an efficient way using a first order approximation of the
form Eq. <a class="reference internal" href="#equation-trotter-first">()</a>. The simplest way to do this is to split the Hamiltonian into
two parts which do not necessarily commute, but for which all the terms within each part do
commute. Since we are dealing with interactions <span class="math notranslate nohighlight">\( h_{(n, n+1)} \)</span> which act on two
neighboring sites, we have <span class="math notranslate nohighlight">\( \left[ h_{(n, n+1)}, h_{(m, m+1)} \right] \propto
\delta_{|n-m|, 1} \)</span>, meaning two terms always commute unless they have a single site in
common. Given this observation, it is natural to split the Hamiltonian into an ‘even’ and an
‘odd’ part,</p>
<div class="math notranslate nohighlight" id="equation-hamsplit">
<span class="eqno">()<a class="headerlink" href="#equation-hamsplit" title="Permalink to this equation">#</a></span>\[H_e = \sum_n h_{(2n, 2n+1)}, \qquad H_o = \sum_n h_{(2n+1, 2n+2)}.\]</div>
<p>It is clear that all local terms within <span class="math notranslate nohighlight">\( H_e \)</span> and <span class="math notranslate nohighlight">\( H_o \)</span> commute, while <span class="math notranslate nohighlight">\(
\left[ H_e, H_o \right] \ne 0 \)</span> since they contain overlapping terms. In particular, this
means that for a given time step <span class="math notranslate nohighlight">\(\Delta t\)</span> the operators <span class="math notranslate nohighlight">\(e^{-i H_e \Delta t}\)</span> and <span class="math notranslate nohighlight">\(e^{-i
H_o \Delta t}\)</span> by applying all disconnected factors <span class="math notranslate nohighlight">\(e^{-i h_s \Delta t}\)</span> contained in <span class="math notranslate nohighlight">\(H_e\)</span>
and <span class="math notranslate nohighlight">\(H_o\)</span> respectively in parallel. If we split the full time interval <span class="math notranslate nohighlight">\(t\)</span> into <span class="math notranslate nohighlight">\(m\)</span> steps,
we get the approximation</p>
<div class="math notranslate nohighlight">
\[e^{-i H t} = \left( e^{-i H_e \frac{t}{m}} e^{-i H_o \frac{t}{m}} \right)^m + \mathcal O
\left( \frac{t^2}{m}\right)\]</div>
<p>where the approximation error can be managed by choosing a sufficiently large <span class="math notranslate nohighlight">\(m\)</span>. If we
assume we can approximate the initial state <span class="math notranslate nohighlight">\(|\psi(0)\rangle\)</span> as an MPS of a reasonable bond
dimension <span class="math notranslate nohighlight">\(\chi\)</span>, we end up with the following procedure for simulating time evolution
according to <span class="math notranslate nohighlight">\(H\)</span>,</p>
<a class="reference internal image-reference" href="../_images/tebd_mps.svg" id="tebd-mps"><img alt="../_images/tebd_mps.svg" class="align-center" height="321" id="tebd-mps" src="../_images/tebd_mps.svg" width="736" /></a>
<p>While we have assumed we start form an initial state which admits an efficient MPS
representation, it is clear that the bond dimension of the corresponding state scales
exponenentially with the number of layers <span class="math notranslate nohighlight">\(m\)</span> if we follow this procedure naively. Instead,
we can retain an efficien representation by manually truncating the bond dimension back to
some sensible value <span class="math notranslate nohighlight">\(\chi'\)</span> after applying each layer. This is done by performing an SVD
after applying the local two-body operator <span class="math notranslate nohighlight">\(e^{-i h_s \Delta t}\)</span> on each pair of MPS tensors
in the following way,</p>
<div class="figure align-center" id="tebd-trunc">
<a class="reference internal image-reference" href="../_images/tebd_trunc.svg"><img alt="../_images/tebd_trunc.svg" height="128" src="../_images/tebd_trunc.svg" width="398" /></a>
</div>
<p>resulting in an efficient MPS algorithm for simulating quantum dynamics.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We can use exactly the same procedure to study the ground-state or low-temperature
properties of a one-dimensional quantum system by evolving the system over an <em>imaginary
time</em> <span class="math notranslate nohighlight">\(\tau\)</span> by approximating the operator <span class="math notranslate nohighlight">\(e^{\tau H}\)</span>.</p>
</div>
<div class="admonition-outlook admonition">
<p class="admonition-title">Outlook</p>
<p>To close out this section, we briefly comment on the higher dimensional generalizations of
the TEBD procedure and the difficulties this brings with it. For local quantum Hamiltonians
in higher dimensions we can follow a similar procedure, where we split the full Hamiltonian
into sum of parts that each only contain non-overlapping local terms. Time evolution can
then be simulated by applying a similar sequence of layers, where in each layer we evolve
with all local operators in a given Hamiltonian part in parallel.</p>
<p>The problem with this approach however is that the local update step <span class="xref std std-ref">tebd_trunc</span> is
ill-conditioned for higher-dimensional networks if the full quantum state is is not taken
into account for the truncation. Indeed, while in the one-dimensional case the rest of the
network surrounding the sites we want to update can be brought into account exactly by
working in appropriate gauge, this is not possible in general. Consider for example a
general network where want to apply some update to the central site,</p>
<a class="reference internal image-reference" href="../_images/tensor_network.svg" id="tensor-network"><img alt="../_images/tensor_network.svg" class="align-center" height="186" id="tensor-network" src="../_images/tensor_network.svg" width="324" /></a>
<p>Since this network contains loops, there is no way to exactly capture the surrounding
network in general. One instead has to resort to approximation techniques for the
<em>environments</em> of a given update site, where the quality of the environment approximations
directly affects the stability of the local update. The simplest way of doing this is to use
the so-called <em>simple update</em> procedure <span id="id5">[<a class="reference internal" href="../References.html#id13" title="H. C. Jiang, Z. Y. Weng, and T. Xiang. Accurate determination of tensor network state of quantum lattice models in two dimensions. Physical Review Letters, 101(9):090603, August 2008. URL: http://arxiv.org/abs/0806.3719, arXiv:0806.3719, doi:10.1103/PhysRevLett.101.090603.">JWX08</a>]</span> where all loops in the
network are simply ignored and the environment is approximated by a product state,</p>
<a class="reference internal image-reference" href="../_images/simple_update.svg" id="simple-update"><img alt="../_images/simple_update.svg" class="align-center" height="108" id="simple-update" src="../_images/simple_update.svg" width="328" /></a>
<p>More accurate results can be obtained by taking into account the full quantum state of the
system in each local update by means of the <em>full update</em> procedure
<span id="id6">[<a class="reference internal" href="../References.html#id14" title="J. Jordan, R. Orús, G. Vidal, F. Verstraete, and J. I. Cirac. Classical Simulation of Infinite-Size Quantum Lattice Systems in Two Spatial Dimensions. Physical Review Letters, 101(25):250602, December 2008. URL: https://link.aps.org/doi/10.1103/PhysRevLett.101.250602, doi:10.1103/PhysRevLett.101.250602.">JOrusV+08</a>]</span>. However, this gain in accuracy comes with a substantial
increase in computational cost due to the full environment approximation at each step.</p>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "julia-1.9"
        },
        kernelOptions: {
            name: "julia-1.9",
            path: "./2-MatrixProductStates"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'julia-1.9'</script>

                    </div>
                    
                </main> <!-- .page__content -->
                


                <footer class="qe-page__footer">

                    <p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://licensebuttons.net/l/by-sa/4.0/80x15.png"></a></p>

                    <p>Creative Commons License &ndash; This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International.</p>

                </footer> <!-- .page__footer -->

            </div> <!-- .page -->

            

            
            <div class="qe-sidebar bd-sidebar inactive" id="site-navigation">

                <div class="qe-sidebar__header">


                    Contents

                </div>

                <nav class="qe-sidebar__nav" id="qe-sidebar-nav" aria-label="Main navigation">
                    <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../1-Introduction/QuantumManyBody.html">
   1. Quantum Many-Body Theory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1-Introduction/Software.html">
   2. Getting Started with Numerics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1-Introduction/LinearAlgebra.html">
   3. (Multi-) Linear Algebra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1-Introduction/TensorNetworks.html">
   4. Tensor Network Theory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1-Introduction/Symmetries.html">
   5. Symmetries in Quantum Many-Body Physics
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Matrix Product States
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="MatrixProductStates.html">
   6. Matrix Product States
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="InfiniteMPS.html">
   7. Infinite Matrix Product States
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Algorithms.html">
   8. Tensor Network Algorithms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="MatrixProductOperators.html">
   9. Matrix Product Operators
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Applications.html">
   10. Applications
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Tensor Network Algorithms
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../3-Algorithms/FixedpointAlgorithms.html">
   11. Fixed-Point algorithms
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Other
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../References.html">
   12. References
  </a>
 </li>
</ul>

                </nav>

                <div class="qe-sidebar__footer">

                </div>

            </div> <!-- .sidebar -->
            
        </div> <!-- .main -->

        <div class="qe-toolbar">

            <div class="qe-toolbar__inner">

                <ul class="qe-toolbar__main">
                    <li data-tippy-content="Table of Contents" class="btn__sidebar"><i data-feather="menu"></i></li>
                    <li data-tippy-content="Home"><a href="../intro.html"><i data-feather="home"></i></a></li>
                    <li><a href="https://quantumghent.github.io/" title="">QuantumGroup@UGent</a></li>
                    <li><a href="https://github.com/quantumghent/" title="GitHub" rel="external nofollow noopener" target="_blank"><i class="fab fa-github"></i></a></li>
                </ul>

                <ul class="qe-toolbar__links">
                    <li class="btn__search">
                        <form action="../search.html" method="get">
                            <input type="search" class="form-control" name="q" id="search-input" placeholder="Search..." aria-label="Search..." autocomplete="off" accesskey="k">
                            <i data-feather="search" id="search-icon"></i>
                        </form>
                    </li>
                    <li data-tippy-content="Fullscreen" class="btn__fullscreen"><i data-feather="maximize"></i></li>
                    <li data-tippy-content="Increase font size" class="btn__plus"><i data-feather="plus-circle"></i></li>
                    <li data-tippy-content="Decrease font size" class="btn__minus"><i data-feather="minus-circle"></i></li>
                    <li data-tippy-content="Change contrast" class="btn__contrast"><i data-feather="sunset"></i></li>
                    <li class="settings-button" id="settingsButton"><div data-tippy-content="Launch Notebook"><i data-feather="play-circle"></i></div></li>
                        <li data-tippy-content="Download PDF" onClick="window.print()"><i data-feather="file"></i></li>
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/quantumghent/TensorTutorials//blob/main/lectures/2-MatrixProductStates/Algorithms-backup.md" download><i data-feather="github"></i></a></li>
                </ul>

            </div>

        </div> <!-- .toolbar -->
        <div id="downloadPDFModal" style="display: none;">
            <ul class="pdf-options" style="display: block;">
                <li class="download-pdf-book" onClick="window.print()">
                    <p>Lecture (PDF)</p>
                </li>
                <li class="download-pdf-file">
                    <a href="" download><p>Book (PDF)</p></a>
                </li>
            </ul>
        </div>
        <div id="settingsModal" style="display: none;">
            <p class="modal-title"> Notebook Launcher </p>
            <div class="modal-desc">
            <p>
                Choose public or private cloud service for "Launch" button.
            </p>
            </div>
            <p class="modal-subtitle">Select a server</p>
            <ul class="modal-servers">
            <li class="active launcher-public">
                <span class="label">Public</span>
                <select id="launcher-public-input">
                
                    <option value="https://colab.research.google.com/github/quantumghent/TensorTutorials.notebooks/blob/main/2-MatrixProductStates/Algorithms-backup.ipynb">Colab</option>
                
                </select>
                <i class="fas fa-check-circle"></i>
            </li>
            <li class="launcher-private">
                <span class="label">Private</span>
                <input type="text" id="launcher-private-input" data-repourl="https://github.com/quantumghent/TensorTutorials.notebooks/" data-urlpath="tree/TensorTutorials.notebooks/2-MatrixProductStates/Algorithms-backup.ipynb" data-branch=main>
                <i class="fas fa-check-circle"></i>
            </li>
            </ul>
            <p class="launch"><a href="https://colab.research.google.com/github/quantumghent/TensorTutorials.notebooks/blob/main/2-MatrixProductStates/Algorithms-backup.ipynb" id="advancedLaunchButton" target="_blank">Launch Notebook</a></p>
            <script>
                // QuantEcon Notebook Launcher
                const launcherTypeElements = document.querySelectorAll('#settingsModal .modal-servers li');
                // Highlight the server type if previous selection exists
                if (typeof localStorage.launcherType !== 'undefined') {
                  for (var i = 0; i < launcherTypeElements.length; i++) {
                    launcherTypeElements[i].classList.remove('active');
                    if ( launcherTypeElements[i].classList.contains(localStorage.launcherType) ) {
                      launcherTypeElements[i].classList.add('active');
                    }
                  }
                }
                // Highlight server type on click and set local storage value
                for (var i = 0; i < launcherTypeElements.length; i++) {
                  launcherTypeElements[i].addEventListener('click', function() {
                    for (var j = 0; j < launcherTypeElements.length; j++) {
                      launcherTypeElements[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    if ( this.classList.contains('launcher-private') ) {
                      localStorage.launcherType = 'launcher-private';
                    } else if ( this.classList.contains('launcher-public') ) {
                      localStorage.launcherType = 'launcher-public';
                    }
                    setLaunchServer();
                  })
                }
                const launcherPublic = document.getElementById('launcher-public-input');
                const launcherPrivate = document.getElementById('launcher-private-input');
                const pageName = "2-MatrixProductStates/Algorithms-backup";
                const repoURL = "https://github.com/quantumghent/TensorTutorials.notebooks/";
                const urlPath = "tree/TensorTutorials.notebooks/2-MatrixProductStates/Algorithms-backup.ipynb";
                const branch = "main"
                const launchNotebookLink = document.getElementById('advancedLaunchButton');

                // Highlight public server option if previous selection exists
                if (typeof localStorage.launcherPublic !== 'undefined') {
                  launcherPublic.value = localStorage.launcherPublic;
                }
                // Update local storage upon public server selection
                launcherPublic.addEventListener('change', (event) => {
                  setLaunchServer();
                });
                // Populate private server input if previous entry exists
                if (typeof localStorage.launcherPrivate !== 'undefined') {
                  launcherPrivate.value = localStorage.launcherPrivate;
                }
                // Update local storage when a private server is entered
                launcherPrivate.addEventListener('input', (event) => {
                  setLaunchServer();
                });

                // Function to update the "Launch Notebook" link href
                function setLaunchServer() {
                  launchNotebookLink.removeAttribute("style")
                  if ( localStorage.launcherType == 'launcher-private' ) {
                    let repoPrefix = "/jupyter/hub/user-redirect/git-pull?repo=" + repoURL + "&branch=" + branch + "&urlpath=" + urlPath;
                    launcherPrivateValue = launcherPrivate.value
                    if (!launcherPrivateValue) {
                        launchNotebookLink.removeAttribute("href")
                        launchNotebookLink.style.background = "grey"
                        return
                    }
                    localStorage.launcherPrivate = launcherPrivateValue;
                    privateServer = localStorage.launcherPrivate.replace(/\/$/, "")
                    if (!privateServer.includes("http")) {
                        privateServer = "http://" + privateServer
                    }
                    launchNotebookLinkURL = privateServer + repoPrefix;
                  } else if ( localStorage.launcherType == 'launcher-public' ) {
                    launcherPublicValue = launcherPublic.options[launcherPublic.selectedIndex].value;
                    localStorage.launcherPublic = launcherPublicValue;
                    launchNotebookLinkURL = localStorage.launcherPublic;
                  }
                  if (launchNotebookLinkURL) launchNotebookLink.href = launchNotebookLinkURL;
                }
                // Check if user has previously selected a server
                if ( (typeof localStorage.launcherPrivate !== 'undefined') || (typeof localStorage.launcherPublic !== 'undefined') ) {
                  setLaunchServer();
                }
                </script>

        </div>

    </div> <!-- .wrapper-->
  </body>
</html>