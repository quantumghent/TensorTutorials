



<!DOCTYPE html>


<html lang="en" data-content_root="" data-theme="light 
">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>18. A Symmetric Tensor Deep Dive: Constructing Your First Tensor Map &#8212; TensorTutorials</title>
    
    <script src="https://unpkg.com/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6.3.1/dist/tippy-bundle.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    
        <script>
            MathJax = {
            loader: {load: ['[tex]/boldsymbol', '[tex]/textmacros']},
            tex: {
                packages: {'[+]': ['boldsymbol', 'textmacros']},
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                processEscapes: true,
                macros: {
                    "argmax" : "arg\\,max",
                    "argmin" : "arg\\,min",
                    "col"    : "col",
                    "Span"   :  "span",
                    "epsilon": "\\varepsilon",
                    "EE": "\\mathbb{E}",
                    "PP": "\\mathbb{P}",
                    "RR": "\\mathbb{R}",
                    "NN": "\\mathbb{N}",
                    "ZZ": "\\mathbb{Z}",
                    "aA": "\\mathcal{A}",
                    "bB": "\\mathcal{B}",
                    "cC": "\\mathcal{C}",
                    "dD": "\\mathcal{D}",
                    "eE": "\\mathcal{E}",
                    "fF": "\\mathcal{F}",
                    "gG": "\\mathcal{G}",
                    "hH": "\\mathcal{H}",
                }
            },
            svg: {
                fontCache: 'global',
                scale: 0.92,
                displayAlign: "center",
            },
            };
        </script>
    
    
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light 
";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/quantumghent-book-theme.5e19e0a6c2e2247c14aaae6dbdd37c4f.css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>


    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script src="../_static/quantumghent-book-theme.ef2ef6c3e8da75e1e736fb5fce08cde6.js"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-3PCWRLGWND"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-3PCWRLGWND');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"argmax": "arg\\,max", "argmin": "arg\\,min"}, "packages": {"[+]": ["physics"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '5-Tutorials/SymmetricTensors';</script>
    <link rel="canonical" href="https://quantumghent.github.io/TensorTutorials/5-Tutorials/SymmetricTensors.html" />
    <link rel="shortcut icon" href="../_static/lectures-favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="19. Finite Entanglement Scaling" href="FiniteEntanglementScaling.html" />
    <link rel="prev" title="17. Time Evolution" href="../4-Algorithms/TimeEvolutionAlgorithms.html" />

<!-- Normal Meta Tags -->
<meta name="author" context="Jacob Bridgeman, Lander Burgelman, Lukas Devos, Jutho Haegeman, Daan Maertens, Bram Vancraeynest-De Cuiper and Kevin Vervoort" />
<meta name="keywords" content="Julia, Tensor Networks, Quantum Many-Body Physics, Statistical Mechanics" />
<meta name="description" content=This website presents a set of lectures on Tensor Network methods />

<!-- Twitter tags -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@" />
<meta name="twitter:title" content="A Symmetric Tensor Deep Dive: Constructing Your First Tensor Map"/>
<meta name="twitter:description" content="This website presents a set of lectures on Tensor Network methods">
<meta name="twitter:creator" content="@">
<meta name="twitter:image" content="">

<!-- Opengraph tags -->
<meta property="og:title" content="A Symmetric Tensor Deep Dive: Constructing Your First Tensor Map" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://quantumghent.github.io/TensorTutorials/5-Tutorials/SymmetricTensors.html" />
<meta property="og:image" content="" />
<meta property="og:description" content="This website presents a set of lectures on Tensor Network methods" />
<meta property="og:site_name" content="TensorTutorials" />
<meta name="theme-color" content="#ffffff" />

  </head>
<body>


    <span id="top"></span>

    <div class="qe-wrapper">

        <div class="qe-main">

            <div class="qe-page" id=5-Tutorials/SymmetricTensors>

                <div class="qe-page__toc">

                    <div class="inner">

                        
                        <div class="qe-page__toc-header">
                            On this page
                        </div>


                        <nav id="bd-toc-nav" class="qe-page__toc-nav">
                            <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#level-0-the-1-dimensional-ising-model">18.1. Level 0: The 1-Dimensional Ising Model</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#level-1-the-mathbb-z-2-symmetric-ising-model">18.2. Level 1: The <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span>-symmetric Ising Model</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-irrep-basis-and-block-sparsity">18.2.1. The irrep basis and block sparsity</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fusion-trees-and-how-to-use-them">18.2.2. Fusion trees and how to use them</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#level-2-the-mathrm-u-1-bose-hubbard-model">18.3. Level 2: The <span class="math notranslate nohighlight">\(\mathrm{U}(1)\)</span> Bose-Hubbard Model</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#directly-constructing-the-hamiltonian-terms">18.3.1. Directly Constructing the Hamiltonian Terms</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creation-and-annihilation-operators-as-symmetric-tensors">18.3.2. Creation and Annihilation Operators as Symmetric Tensors</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#level-3-fermions-and-the-kitaev-model">18.4. Level 3: Fermions and the Kitaev Model</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fermion-parity-symmetry">18.4.1. Fermion Parity Symmetry</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#constructing-the-hamiltonian">18.4.2. Constructing the Hamiltonian</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#level-4-non-abelian-symmetries-and-the-quantum-heisenberg-model">18.5. Level 4: Non-Abelian Symmetries and the Quantum Heisenberg Model</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#block-sparsity-revisited-the-wigner-eckart-theorem">18.5.1. Block Sparsity Revisited: The Wigner-Eckart Theorem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-generic-approach-to-the-spin-1-heisenberg-model-wigner-eckart-in-action">18.5.2. The ‘Generic’ Approach to the Spin-1 Heisenberg Model: Wigner-Eckart in Action</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#an-elegant-approach-to-the-heisenberg-model">18.5.3. An ‘Elegant’ Approach to the Heisenberg Model</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mathrm-su-n-generalization">18.5.4. <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> generalization</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#level-5-anyonic-symmetries-and-the-golden-chain">18.6. Level 5: Anyonic Symmetries and the Golden Chain</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#to-be-added">18.7. To Be Added</a></li>
</ul>
                            <p class="logo">
                                
                                    
                                    <a href=https://quantumghent.github.io/><img src="../_static/logo.png" class="logo" alt="logo"></a>
                                    
                                
                            </p>

                            <p class="powered">Powered by <a href="https://jupyterbook.org/">Jupyter Book</a></p>

                        </nav>

                        <div class="qe-page__toc-footer">
                            
                            
                            <p><a href="#top"><strong>Back to top</strong></a></p>
                        </div>

                    </div>

                </div>

                <div class="qe-page__header">

                    <div class="qe-page__header-copy">

                        <p class="qe-page__header-heading"><a href="../intro.html">TensorTutorials</a></p>

                        <p class="qe-page__header-subheading">A Symmetric Tensor Deep Dive: Constructing Your First Tensor Map</p>

                    </div>

                    <p class="qe-page__header-authors">Jacob Bridgeman, Lander Burgelman, Lukas Devos, Jutho Haegeman, Daan Maertens, Bram Vancraeynest-De Cuiper and Kevin Vervoort</p>

                </div> <!-- .page__header -->



                
                <main class="qe-page__content" role="main">
                    
                    <div>
                        
  <div class="tex2jax_ignore mathjax_ignore section" id="a-symmetric-tensor-deep-dive-constructing-your-first-tensor-map">
<h1><span class="section-number">18. </span>A Symmetric Tensor Deep Dive: Constructing Your First Tensor Map<a class="headerlink" href="#a-symmetric-tensor-deep-dive-constructing-your-first-tensor-map" title="Permalink to this heading">#</a></h1>
<p>In this tutorial, we will demonstrate how to construct specific <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>s which are relevant to some common physical systems, with an increasing degree of complexity. We will assume the reader has gone through the tutorial sections on <a class="reference internal" href="../2-TensorNetworks/TensorNetworks.html#tensor-networks"><span class="std std-ref">tensor network theory</span></a> and <a class="reference internal" href="../2-TensorNetworks/Symmetries.html#symmetric-tensors"><span class="std std-ref">symmetries in tensor networks</span></a>. In going through these examples we aim to provide a relatively gently introduction to the meaning of <a class="reference external" href="https://jutho.github.io/TensorKit.jl/latest/man/sectors/#ss_sectors">symmetry sectors</a> and <a class="reference external" href="https://jutho.github.io/TensorKit.jl/latest/man/sectors/#ss_rep">vector spaces</a> within the context of <a class="reference external" href="https://jutho.github.io/TensorKit.jl/latest/">TensorKit.jl</a>, <a class="reference external" href="https://jutho.github.io/TensorKit.jl/latest/man/tensors/#ss_tensor_construction">how to initialize a <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> over a given vector space</a> and finally how to manually set the data of a symmetric <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>. We will keep our discussion as intuitive and simple as possible, only adding as many technical details as strictly necessary to understand each example. When considering a different physical system of interest, you should then be able to adatpt these recipes and the intuition behind them to your specific problem at hand.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Many of these examples are already implemented in the <a class="reference external" href="https://github.com/maartenvd/MPSKitModels.jl">MPSKitModels.jl package</a>, in which case we basically provide a narrated walk-through of the corresponding code.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">LinearAlgebra</span>
<span class="k">using</span><span class="w"> </span><span class="n">TensorKit</span>
<span class="k">using</span><span class="w"> </span><span class="n">MPSKitModels</span>
<span class="k">using</span><span class="w"> </span><span class="n">WignerSymbols</span>
<span class="k">using</span><span class="w"> </span><span class="n">SUNRepresentations</span>
<span class="k">using</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="c"># for showcase testing</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="level-0-the-1-dimensional-ising-model">
<h2><span class="section-number">18.1. </span>Level 0: The 1-Dimensional Ising Model<a class="headerlink" href="#level-0-the-1-dimensional-ising-model" title="Permalink to this heading">#</a></h2>
<p>As the most basic example, we will consider the <a class="reference external" href="https://en.wikipedia.org/wiki/Transverse-field_Ising_model">1-dimensional transverse-field Ising model</a>, whose Hamiltonian is given by</p>
<div class="math notranslate nohighlight" id="equation-eq-isingham">
<span class="eqno">(18.1)<a class="headerlink" href="#equation-eq-isingham" title="Permalink to this equation">#</a></span>\[H = -J \left (\sum_{\langle i, j \rangle} Z_i Z_j + g \sum_{i} X_i\right).\]</div>
<p>Here, <span class="math notranslate nohighlight">\(X_i\)</span> and <span class="math notranslate nohighlight">\(Z_i\)</span> are the <a class="reference external" href="https://en.wikipedia.org/wiki/Pauli_matrices">Pauli operators</a> acting on site <span class="math notranslate nohighlight">\(i\)</span>, and the first sum runs over pairs of nearest neighbors <span class="math notranslate nohighlight">\(\langle i, j \rangle\)</span>. This model has a global <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> symmetry, as it is invariant under the transformation <span class="math notranslate nohighlight">\(U H U^\dagger = H\)</span> where the symmetry transformation <span class="math notranslate nohighlight">\(U\)</span> is given by a global spin flip,</p>
<div class="math notranslate nohighlight" id="equation-eq-z2gen">
<span class="eqno">(18.2)<a class="headerlink" href="#equation-eq-z2gen" title="Permalink to this equation">#</a></span>\[U = \prod_i X_i.\]</div>
<p>We will circle back to the implications of this symmetry later.</p>
<p>As a warmup we will implement the Hamiltonian <a class="reference internal" href="#equation-eq-isingham">(18.1)</a> in the standard way by encoding the matrix elements of the single-site operators <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Z\)</span> into aan array of complex numbers, and then combine them in a suitable way to get the Hamiltonian terms. Instead of using plain Julia arrays, we will use a representation in terms of <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>s over complex vector spaces. These will essentially just be wrappers around base arrays at this point, but their construction requires some consideration of the notion of <em>spaces</em>, which generalize the notion of <code class="docutils literal notranslate"><span class="pre">size</span></code> for arrays. Each of the operators <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Z\)</span> acts on a local 2-dimensional complex vector space. In the context of TensorKit.jl such a space can be represented as <code class="docutils literal notranslate"><span class="pre">ComplexSpace(2)</span></code>, or using the convenient shorthand <code class="docutils literal notranslate"><span class="pre">ℂ^2</span></code>. A single-site Pauli operator maps from a domain physical space to a codomain physical space, and can therefore be represented as instances of a <code class="docutils literal notranslate"><span class="pre">TensorMap(...,</span> <span class="pre">ℂ^2</span> <span class="pre">←</span> <span class="pre">ℂ^2)</span></code>. The corresponding data can then be filled in by hand according to the familiar Pauli matrices in the following way:</p>
<div class="cell tag_hide-output docutils container">
<div class="cell_input above-output-prompt docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="c"># initialize numerical data for Pauli matrices</span>
<span class="n">x_mat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span>
<span class="n">z_mat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="c"># construct physical Hilbert space</span>
<span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ℂ</span><span class="o">^</span><span class="mi">2</span>

<span class="c"># construct the physical operators as TensorMaps</span>
<span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">x_mat</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="n">Z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">z_mat</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>

<span class="c"># combine single-site operators into two-site operator</span>
<span class="n">ZZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Z</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">Z</span>
</pre></div>
</div>
</div>
<details class="hide below-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell output</span>
<span class="expanded">Hide code cell output</span>
</summary>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap((ℂ^2 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^2)):
[:, :, 1, 1] =
 1.0 + 0.0im  0.0 + 0.0im
 0.0 + 0.0im  0.0 + 0.0im

[:, :, 2, 1] =
  0.0 + 0.0im   0.0 + 0.0im
 -1.0 + 0.0im  -0.0 + 0.0im

[:, :, 1, 2] =
 0.0 + 0.0im  -1.0 + 0.0im
 0.0 + 0.0im  -0.0 + 0.0im

[:, :, 2, 2] =
  0.0 + 0.0im  -0.0 + 0.0im
 -0.0 + 0.0im   1.0 - 0.0im
</pre></div>
</div>
</div>
</details>
</div>
<p>We can easily verify that our operators have the desired form by checking their data in the computational basis:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">ZZ</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap((ℂ^2 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^2)):
[:, :, 1, 1] =
 1.0 + 0.0im  0.0 + 0.0im
 0.0 + 0.0im  0.0 + 0.0im

[:, :, 2, 1] =
  0.0 + 0.0im   0.0 + 0.0im
 -1.0 + 0.0im  -0.0 + 0.0im

[:, :, 1, 2] =
 0.0 + 0.0im  -1.0 + 0.0im
 0.0 + 0.0im  -0.0 + 0.0im

[:, :, 2, 2] =
  0.0 + 0.0im  -0.0 + 0.0im
 -0.0 + 0.0im   1.0 - 0.0im
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">X</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap(ℂ^2 ← ℂ^2):
 0.0 + 0.0im  1.0 + 0.0im
 1.0 + 0.0im  0.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In order to combine these local operators into a concrete Hamiltonian that can be used in <a class="reference external" href="https://github.com/maartenvd/MPSKit.jl">MPSKit.jl</a> we can make use of the convenient <code class="docutils literal notranslate"><span class="pre">&#64;mpoham</span></code> macro exported by <a class="reference external" href="https://github.com/maartenvd/MPSKitModels.jl">MPSKitModels.jl</a>. For an infinite translation invariant Ising chain, we can use the following piece of code which produces the Hamiltonian in an interesting-looking form (see MPSKit.jl for details on this format).</p>
</div>
<div class="cell tag_hide-output docutils container">
<div class="cell_input above-output-prompt docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">lattice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">InfiniteChain</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">H</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nd">@mpoham</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="n">sum</span><span class="p">(</span><span class="n">nearest_neighbours</span><span class="p">(</span><span class="n">lattice</span><span class="p">))</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kt">ZZ</span><span class="p">{</span><span class="kt">i</span><span class="p">,</span><span class="kt">j</span><span class="p">}</span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">vertices</span><span class="p">(</span><span class="n">lattice</span><span class="p">))</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">i</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kt">X</span><span class="p">{</span><span class="kt">i</span><span class="p">}</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
<details class="hide below-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell output</span>
<span class="expanded">Hide code cell output</span>
</summary>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>MPSKit.MPOHamiltonian{ComplexSpace, TrivialTensorMap{ComplexSpace, 2, 2, Matrix{ComplexF64}}, ComplexF64}(MPSKit.SparseMPOSlice{ComplexSpace, TrivialTensorMap{ComplexSpace, 2, 2, Matrix{ComplexF64}}, ComplexF64}[[TensorMap((ℂ^1 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^1)):
[:, :, 1, 1] =
 1.0 + 0.0im  0.0 + 0.0im

[:, :, 2, 1] =
 0.0 + 0.0im  1.0 + 0.0im
 TensorMap((ℂ^1 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^1)):
[:, :, 1, 1] =
 -1.4142135623730945 + 0.0im  0.0 + 0.0im

[:, :, 2, 1] =
 0.0 + 0.0im  1.414213562373095 + 0.0im
 TensorMap((ℂ^1 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^1)):
[:, :, 1, 1] =
 0.0 + 0.0im  1.0 + 0.0im

[:, :, 2, 1] =
 1.0 + 0.0im  0.0 + 0.0im
; TensorMap((ℂ^1 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^1)):
[:, :, 1, 1] =
 0.0 + 0.0im  0.0 + 0.0im

[:, :, 2, 1] =
 0.0 + 0.0im  0.0 + 0.0im
 TensorMap((ℂ^1 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^1)):
[:, :, 1, 1] =
 0.0 + 0.0im  0.0 + 0.0im

[:, :, 2, 1] =
 0.0 + 0.0im  0.0 + 0.0im
 TensorMap((ℂ^1 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^1)):
[:, :, 1, 1] =
 -0.7071067811865476 + 0.0im  0.0 + 0.0im

[:, :, 2, 1] =
 0.0 + 0.0im  0.7071067811865475 + 0.0im
; TensorMap((ℂ^1 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^1)):
[:, :, 1, 1] =
 0.0 + 0.0im  0.0 + 0.0im

[:, :, 2, 1] =
 0.0 + 0.0im  0.0 + 0.0im
 TensorMap((ℂ^1 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^1)):
[:, :, 1, 1] =
 0.0 + 0.0im  0.0 + 0.0im

[:, :, 2, 1] =
 0.0 + 0.0im  0.0 + 0.0im
 TensorMap((ℂ^1 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^1)):
[:, :, 1, 1] =
 1.0 + 0.0im  0.0 + 0.0im

[:, :, 2, 1] =
 0.0 + 0.0im  1.0 + 0.0im
]])
</pre></div>
</div>
</div>
</details>
</div>
</div>
<div class="section" id="level-1-the-mathbb-z-2-symmetric-ising-model">
<h2><span class="section-number">18.2. </span>Level 1: The <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span>-symmetric Ising Model<a class="headerlink" href="#level-1-the-mathbb-z-2-symmetric-ising-model" title="Permalink to this heading">#</a></h2>
<div class="section" id="the-irrep-basis-and-block-sparsity">
<h3><span class="section-number">18.2.1. </span>The irrep basis and block sparsity<a class="headerlink" href="#the-irrep-basis-and-block-sparsity" title="Permalink to this heading">#</a></h3>
<p>Let us now return to the global <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> invariance of the Hamiltonian <a class="reference internal" href="#equation-eq-isingham">(18.1)</a>, and consider what this implies for its local terms <span class="math notranslate nohighlight">\(ZZ\)</span> and <span class="math notranslate nohighlight">\(X\)</span>. Representing these operators as <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>s, the invariance of <span class="math notranslate nohighlight">\(H\)</span> under a global <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> transformation implies the following identities for the local tensors:</p>
<div class="figure align-center" id="zzx-symm">
<a class="reference internal image-reference" href="../_images/ZZX_symm.svg"><img alt="../_images/ZZX_symm.svg" height="153" src="../_images/ZZX_symm.svg" width="286" /></a>
</div>
<p>Recalling the <a class="reference internal" href="../2-TensorNetworks/Symmetries.html#symmetric-tensors"><span class="std std-ref">discussion on symmetries in tensor networks</span></a>, we recognize that these identitities precisely mean that these local tensors transform trivially under a tensor product representation of <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span>. This implies that, in an appropriate basis for the local physical vector space, our local tensors would become block-diagonal where each so-called <em>matrix block</em> is labeled by a <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> irrep. From the same discussion, we recall that the appropriate local basis transformation is precisely the one that brings the local representation <span class="math notranslate nohighlight">\(X\)</span> into block-diagonal form. Clearly, this transformation is nothing more than the Hadamard transformation which maps the computational basis of <span class="math notranslate nohighlight">\(Z\)</span> eigenstates <span class="math notranslate nohighlight">\(\{\ket{\uparrow}, \ket{\downarrow}\}\)</span> to that of the <span class="math notranslate nohighlight">\(X\)</span> eigenstates <span class="math notranslate nohighlight">\(\{\ket{+}, \ket{-}\}\)</span> defined as <span class="math notranslate nohighlight">\(\ket{+} = \frac{\ket{\uparrow} + \ket{\downarrow}}{\sqrt{2}}\)</span> and <span class="math notranslate nohighlight">\(\ket{-} = \frac{\ket{\uparrow} - \ket{\downarrow}}{\sqrt{2}}\)</span>. In the current context, this basis is referred to as the <em>irrep basis</em> of <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span>, where the local basis state <span class="math notranslate nohighlight">\(\ket{+}\)</span> corresponds to the trivial representation of <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> while <span class="math notranslate nohighlight">\(\ket{-}\)</span> corresponds to the sign representation.</p>
<p>Next, let’s make the statement that ‘the matrix blocks of the local tensors are labeled by <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> irreps’ more concrete. To this end, consider the action of <span class="math notranslate nohighlight">\(ZZ\)</span> in the irrep basis, which is given by the four nonzero matrix elements</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
ZZ : \mathbb C^2 \otimes \mathbb C^2 &amp;\to \mathbb C^2 \otimes \mathbb C^2 : \\
\ket{+} \otimes \ket{+} &amp;\mapsto \ket{-} \otimes \ket{-},  \\
\ket{+} \otimes \ket{-} &amp;\mapsto \ket{-} \otimes \ket{+},  \\
\ket{-} \otimes \ket{+} &amp;\mapsto \ket{+} \otimes \ket{-},  \\
\ket{-} \otimes \ket{-} &amp;\mapsto \ket{+} \otimes \ket{+}.
\end{align}\end{split}\]</div>
<p>If we denote the trivial <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> irrep by <span class="math notranslate nohighlight">\('0'\)</span>, corresponding to a local <span class="math notranslate nohighlight">\(\ket{+}\)</span> state, and the sign irrep by <span class="math notranslate nohighlight">\('1'\)</span>, corresponding to a local <span class="math notranslate nohighlight">\(\ket{-}\)</span> state, and recall that in this notation the fusion rules of <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> are given by addition modulo 2, we can associate each of the above matrix elements to a so-called <em>fusion tree</em> of <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> irreps with a corresponding coefficient of 1,</p>
<div class="figure align-center" id="z2-fusiontrees">
<a class="reference internal image-reference" href="../_images/Z2_fusiontrees.svg"><img alt="../_images/Z2_fusiontrees.svg" height="130" src="../_images/Z2_fusiontrees.svg" width="393" /></a>
</div>
<p>From this we can observe our previous statement very clearly: the <span class="math notranslate nohighlight">\(ZZ\)</span> operator indeed consists of two distinct two-dimensional matrix blocks, each of which are labeled by the value of the <em>coupled irrep</em> on the middle line of each fusion tree. The first block corresponds to the even coupled irrep ‘0’, and acts within the two-dimensional subspace spanned by <span class="math notranslate nohighlight">\(\{\ket{+,+}, \ket{-,-}\}\)</span>, while the second block corresponds to the odd coupled irrep ‘1’, and acts within the two-dimensional subspace spanned by <span class="math notranslate nohighlight">\(\{\ket{+,-}, \ket{-,+}\}\)</span>. In TensorKit.jl, this block-diagonal structure of a symmetric tensor is explicitly encoded into its representation as a <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>, where only the matrix blocks corresponding to each coupled irrep are stored.</p>
<p>For our current purposes however, we never really need to explicitly consider these matrix blocks. Indeed, when constructing a <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> it is sufficient to set its data by manually assigning a matrix element to each <a class="reference internal" href="#z2-fusiontrees"><span class="std std-ref">fusion tree of the form above</span></a> labeled by a given tensor product of irreps. This matrix element is then automatically inserted into the appropriate matrix block. So, for the purpose of this tutorial <strong>we will interpret a symmetric <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> simply as a list of fusion trees, to each of which corresponds a certain reduced matrix element</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general, such a reduced matrix element is not necessarily a scalar, but rather an array whose size is determined by the degeneracy of the irreps in the codomain and domain of the fusion tree. For this reason, a reduced matrix element associated to a given fusion tree is also referred to as an <em>array block</em>. In the following we will use terms ‘reduced matrix element’, ‘array block’ or just ‘block’ interchangeably. However, it should be remembered that these are distinct from the matrix blocks in the block-diagonal decomposition of the tensor.</p>
</div>
</div>
<div class="section" id="fusion-trees-and-how-to-use-them">
<span id="fusion-trees"></span><h3><span class="section-number">18.2.2. </span>Fusion trees and how to use them<a class="headerlink" href="#fusion-trees-and-how-to-use-them" title="Permalink to this heading">#</a></h3>
<p>This view of the underlying symmetry structure in terms of fusion trees and corresponding array blocks is a very convenient way of working with the <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> type. Consider a generic fusion tree of the form</p>
<div class="figure align-center" id="fusiontree">
<a class="reference internal image-reference" href="../_images/fusiontree.svg"><img alt="../_images/fusiontree.svg" height="132" src="../_images/fusiontree.svg" width="57" /></a>
</div>
<p>which can be used to label a block of a <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> corresponding to a two-site operator. This object should actually be seen as a <em>pair of fusion trees</em>. The first member of the pair, related to the codomain of the <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>, is referred to as the <em>splitting tree</em> and encodes how the <em>coupled charge</em> <span class="math notranslate nohighlight">\(c\)</span> splits into the <em>uncoupled charges</em> <span class="math notranslate nohighlight">\(s_1\)</span> and <span class="math notranslate nohighlight">\(s_2\)</span>. The second member of the pair, related to the domain of the <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>, is referred to as the <em>fusion tree</em> and encodes how the uncoupled charges <span class="math notranslate nohighlight">\(f_1\)</span> and <span class="math notranslate nohighlight">\(f_2\)</span> fuse to the coupled charge <span class="math notranslate nohighlight">\(c\)</span>. Both the splitting and fusion tree can be represented as a <a class="reference external" href="https://jutho.github.io/TensorKit.jl/latest/lib/sectors/#TensorKit.FusionTree"><code class="docutils literal notranslate"><span class="pre">TensorKit.FusionTree</span></code></a> instance. You will find such a <code class="docutils literal notranslate"><span class="pre">FusionTree</span></code> has the following properties encoded into its fields:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">uncoupled::NTuple{N,I}</span></code>: a list of <code class="docutils literal notranslate"><span class="pre">N</span></code> uncoupled charges of type <code class="docutils literal notranslate"><span class="pre">I&lt;:Sector</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">coupled::I</span></code>: a single coupled charge of type <code class="docutils literal notranslate"><span class="pre">I&lt;:Sector</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isdual::NTuple{N,Bool}</span></code>: a list of booleans indicating whether the corresponding uncoupled charge is dual</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">innerlines::NTuple{M,I}</span></code>: a list of inner lines of type <code class="docutils literal notranslate"><span class="pre">I&lt;:Sector</span></code> of length <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">N</span> <span class="pre">-</span> <span class="pre">2</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices::NTuple{L,T}</span></code>: list of fusion vertex labels of type <code class="docutils literal notranslate"><span class="pre">T</span></code> and length <code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">N</span> <span class="pre">-</span> <span class="pre">1</span></code></p></li>
</ul>
<p>For our current application only <code class="docutils literal notranslate"><span class="pre">uncoupled</span></code> and <code class="docutils literal notranslate"><span class="pre">coupled</span></code> are relevant, since <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> irreps are self-dual and have Abelian fusion rules. We will come back to these other properties when discussion more involved applications. Given some <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>, the method <code class="docutils literal notranslate"><span class="pre">TensorKit.fusiontrees(t::TensorMap)</span></code> returns an iterator over all pairs of splitting and fusion trees that label the blocks of <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<p>We can now put this into practice by directly constructing the <span class="math notranslate nohighlight">\(ZZ\)</span> operator in the irrep basis as a <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span>-symmetric <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>. We will do this in three steps:</p>
<ul class="simple">
<li><p>First we construct the physical space at each site as a <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span>-graded vector space.</p></li>
<li><p>Then we initialize an empty <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> with the correct domain and codomain vector spaces built from the previously constructed physical space.</p></li>
<li><p>And finally we iterate over all splitting and fusion tree pairs and manually fill in the corresponding nonzero blocks of the operator.</p></li>
</ul>
<p>After the basis transform to the irrep basis, we can view the two-dimensional complex physical vector space we started with as being spanned by the trivial and sign irrep of <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span>. In the language of TensorKit.jl, this can be implemented as a <code class="docutils literal notranslate"><span class="pre">Z2Space</span></code>, an alias for a <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span>-<a class="reference external" href="https://jutho.github.io/TensorKit.jl/latest/lib/spaces/#TensorKit.GradedSpace">graded vector space</a> <code class="docutils literal notranslate"><span class="pre">Vect[Z2Irrep]</span></code>, which contains the trivial irrep <code class="docutils literal notranslate"><span class="pre">Z2Irrep(0)</span></code> with degeneracy 1 and the sign irrep <code class="docutils literal notranslate"><span class="pre">Z2Irrep(1)</span></code> with degeneracy 1. We can define this space in the following way and check its dimension:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Z2Space</span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="n">dim</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<p>Given this physical space, we can initialize the <span class="math notranslate nohighlight">\(ZZ\)</span> operator as an empty <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> with the appropriate structure.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">ZZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap((Rep[ℤ₂](0=&gt;1, 1=&gt;1) ⊗ Rep[ℤ₂](0=&gt;1, 1=&gt;1)) ← (Rep[ℤ₂](0=&gt;1, 1=&gt;1) ⊗ Rep[ℤ₂](0=&gt;1, 1=&gt;1))):
* Data for sector (Irrep[ℤ₂](0), Irrep[ℤ₂](0)) ← (Irrep[ℤ₂](0), Irrep[ℤ₂](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[ℤ₂](1), Irrep[ℤ₂](1)) ← (Irrep[ℤ₂](0), Irrep[ℤ₂](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[ℤ₂](0), Irrep[ℤ₂](0)) ← (Irrep[ℤ₂](1), Irrep[ℤ₂](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[ℤ₂](1), Irrep[ℤ₂](1)) ← (Irrep[ℤ₂](1), Irrep[ℤ₂](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[ℤ₂](1), Irrep[ℤ₂](0)) ← (Irrep[ℤ₂](1), Irrep[ℤ₂](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[ℤ₂](0), Irrep[ℤ₂](1)) ← (Irrep[ℤ₂](1), Irrep[ℤ₂](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[ℤ₂](1), Irrep[ℤ₂](0)) ← (Irrep[ℤ₂](0), Irrep[ℤ₂](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[ℤ₂](0), Irrep[ℤ₂](1)) ← (Irrep[ℤ₂](0), Irrep[ℤ₂](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<p>The output of this command again demonstrates the underlying structure of a symmetric tensor. We see that all eight valid fusion trees with two incoming irreps and two outgoing irreps <a class="reference internal" href="#fusiontree"><span class="std std-ref">of the type above</span></a> are listed with their corresponding block data. Each of these blocks is an array of shape <span class="math notranslate nohighlight">\((1, 1, 1, 1)\)</span> since each irrep occuring in the space <span class="math notranslate nohighlight">\(V\)</span> has degeneracy 1. Using the <code class="docutils literal notranslate"><span class="pre">fusiontrees</span></code> method and the fact that we can index a <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> using a splitting/fusion tree pair, we can now fill in the nonzero blocks of the operator by observing that the <span class="math notranslate nohighlight">\(ZZ\)</span> operator flips the irreps of the uncoupled charges in the domain with respect to the codomain, as shown in the diagrams above. Flipping a given <code class="docutils literal notranslate"><span class="pre">Z2Irrep</span></code> in the codomain can be implemented by fusing them with the sign irrep <code class="docutils literal notranslate"><span class="pre">Z2Irrep(1)</span></code>, giving:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">flip_charge</span><span class="p">(</span><span class="n">charge</span><span class="o">::</span><span class="kt">Z2Irrep</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">only</span><span class="p">(</span><span class="n">charge</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">Z2Irrep</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">s</span><span class="o">.</span><span class="n">uncoupled</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">map</span><span class="p">(</span><span class="n">flip_charge</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">)</span>
<span class="w">        </span><span class="n">ZZ</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
<span class="n">ZZ</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap((Rep[ℤ₂](0=&gt;1, 1=&gt;1) ⊗ Rep[ℤ₂](0=&gt;1, 1=&gt;1)) ← (Rep[ℤ₂](0=&gt;1, 1=&gt;1) ⊗ Rep[ℤ₂](0=&gt;1, 1=&gt;1))):
* Data for sector (Irrep[ℤ₂](0), Irrep[ℤ₂](0)) ← (Irrep[ℤ₂](0), Irrep[ℤ₂](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[ℤ₂](1), Irrep[ℤ₂](1)) ← (Irrep[ℤ₂](0), Irrep[ℤ₂](0)):
[:, :, 1, 1] =
 1.0 + 0.0im
* Data for sector (Irrep[ℤ₂](0), Irrep[ℤ₂](0)) ← (Irrep[ℤ₂](1), Irrep[ℤ₂](1)):
[:, :, 1, 1] =
 1.0 + 0.0im
* Data for sector (Irrep[ℤ₂](1), Irrep[ℤ₂](1)) ← (Irrep[ℤ₂](1), Irrep[ℤ₂](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[ℤ₂](1), Irrep[ℤ₂](0)) ← (Irrep[ℤ₂](1), Irrep[ℤ₂](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[ℤ₂](0), Irrep[ℤ₂](1)) ← (Irrep[ℤ₂](1), Irrep[ℤ₂](0)):
[:, :, 1, 1] =
 1.0 + 0.0im
* Data for sector (Irrep[ℤ₂](1), Irrep[ℤ₂](0)) ← (Irrep[ℤ₂](0), Irrep[ℤ₂](1)):
[:, :, 1, 1] =
 1.0 + 0.0im
* Data for sector (Irrep[ℤ₂](0), Irrep[ℤ₂](1)) ← (Irrep[ℤ₂](0), Irrep[ℤ₂](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<p>Indeed, the resulting <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> exactly encodes the matrix elements of the <span class="math notranslate nohighlight">\(ZZ\)</span> operator shown in <a class="reference internal" href="#z2-fusiontrees"><span class="std std-ref">the diagrams above</span></a>. The <span class="math notranslate nohighlight">\(X\)</span> operator can be constructed in a similar way. Since it is by definition diagonal in the irrep basis with blocks directly corresponding to the trivial and sign irrep, its construction is particularly simple:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">only</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Z2Irrep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="n">X</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">X</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
<span class="n">X</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap(Rep[ℤ₂](0=&gt;1, 1=&gt;1) ← Rep[ℤ₂](0=&gt;1, 1=&gt;1)):
* Data for sector (Irrep[ℤ₂](0),) ← (Irrep[ℤ₂](0),):
 1.0 + 0.0im
* Data for sector (Irrep[ℤ₂](1),) ← (Irrep[ℤ₂](1),):
 -1.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<p>Given these local operators, we can use them to construct the full manifestly <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span>-symmetric Hamiltonian.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An important observation is that when explicitly imposing the <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> symmetry we directly constructed the full <span class="math notranslate nohighlight">\(ZZ\)</span> operator as a single symmetric tensor. This in contrast to the case without symmetries, where we constructed a single-site <span class="math notranslate nohighlight">\(Z\)</span> operator and then combined them into a two-site operator. Clearly this can no longer be done when imposing <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span>, since a single <span class="math notranslate nohighlight">\(Z\)</span> is not invariant under conjugation with the symmetry operator <span class="math notranslate nohighlight">\(X\)</span>. One might wonder whether it is still possible to construct a two-site Hamiltonian term by combining local objects. This is possible if one introduces an auxiliary index on the local tensors that carries a non-trivial charge. The intuition behind this will become more clear in the next example.</p>
</div>
</div>
</div>
<div class="section" id="level-2-the-mathrm-u-1-bose-hubbard-model">
<h2><span class="section-number">18.3. </span>Level 2: The <span class="math notranslate nohighlight">\(\mathrm{U}(1)\)</span> Bose-Hubbard Model<a class="headerlink" href="#level-2-the-mathrm-u-1-bose-hubbard-model" title="Permalink to this heading">#</a></h2>
<p>For our next example we will consider the <a class="reference external" href="https://en.wikipedia.org/wiki/Bose%E2%80%93Hubbard_model">Bose-Hubbard model</a>, which describes interacting bosons on a lattice. The Hamiltonian of this model is given by</p>
<div class="math notranslate nohighlight" id="equation-eq-bhh">
<span class="eqno">(18.3)<a class="headerlink" href="#equation-eq-bhh" title="Permalink to this equation">#</a></span>\[H = -t \sum_{\langle i,j \rangle} \left( a_{i}^+ a_{j}^- + a_{i}^- a_{j}^+ \right) - \mu \sum_i N_i + \frac{U}{2} \sum_i N_i(N_i - 1).\]</div>
<p>This Hamiltonian is defined on the <a class="reference internal" href="../1-Introduction/FockSpace.html#fock-space"><span class="std std-ref">Fock space</span></a> associated to a chain of bosons, where the action bosonic creation, annihilation and number operators <span class="math notranslate nohighlight">\(a^+\)</span>, <span class="math notranslate nohighlight">\(a^-\)</span> and <span class="math notranslate nohighlight">\(N = a^+ a^-\)</span> in the local occupation number basis is given by</p>
<div class="math notranslate nohighlight" id="equation-eq-bosonopmatel">
<span class="eqno">(18.4)<a class="headerlink" href="#equation-eq-bosonopmatel" title="Permalink to this equation">#</a></span>\[\begin{split}\begin{align}
a^+ \ket{n} &amp;= \sqrt{n + 1} \ket{n + 1} \\
a^- \ket{n} &amp;= \sqrt{n} \ket{n - 1} \\
N \ket{n} &amp;= n \ket{n}
\end{align}\end{split}\]</div>
<p>Their bosonic nature can be summarized by the familiar the commutation relations</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\left[a_i^-, a_j^-\right] &amp;= \left[a_i^+, a_j^+\right] = 0 \\
\left[a_i^-, a_j^+\right] &amp;= \delta_{ij} \\
\left[N, a^+\right] &amp;= a^+ \\
\left[N, a^-\right] &amp;= -a^- \\
\end{align*}\end{split}\]</div>
<p>This Hamiltonian is invariant under conjugation by the global particle number operator, <span class="math notranslate nohighlight">\(U H U^\dagger = H\)</span>, where</p>
<div class="math notranslate nohighlight">
\[U = \sum_i N_i\]</div>
<p>This invariance corresponds to a <span class="math notranslate nohighlight">\(\mathrm{U}(1)\)</span> particle number symmetry, which can again be manifestly imposed when constructing the Hamiltonian terms as <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>s. From the representation theory of <span class="math notranslate nohighlight">\(\mathrm{U}(1)\)</span> we know that it’s irreps are all one-dimensional and can be labeled by integers, where the fusion of two irreps is given by addition.</p>
<div class="section" id="directly-constructing-the-hamiltonian-terms">
<h3><span class="section-number">18.3.1. </span>Directly Constructing the Hamiltonian Terms<a class="headerlink" href="#directly-constructing-the-hamiltonian-terms" title="Permalink to this heading">#</a></h3>
<p>We recall from our discussion on the <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> symmetric Ising model that, in order to construct the Hamiltonian terms as symmetric tensors, we should work in the irrep basis where the symmetry transformation is block diagonal. In the current case, the symmetry operation is the particle number operator, which is already diagonal in the occupation number basis. Therefore, we don’t need an additional local basis transformation this time, and can just observe that each local basis state can be identified with the <span class="math notranslate nohighlight">\(\mathrm{U}(1)\)</span> irrep associated to the corresponding occupation number.</p>
<p>Following the same approach as before, we first write down the action of the Hamiltonian terms in the irrep basis:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
a_i^+ a_j^- \ket{n_i, n_j} &amp;= \sqrt{(n_i + 1)n_j} \ket{n_i + 1, n_j - 1} \\
a_i^- a_j^+ \ket{n_i, n_j} &amp;= \sqrt{n_i(n_j + 1)} \ket{n_i - 1, n_j + 1} \\
N \ket{n} &amp;= n \ket{n}
\end{align*}\end{split}\]</div>
<p>It is then a simple observation that these matrix elements are exactly captured by the following <span class="math notranslate nohighlight">\(\mathrm{U}(1)\)</span> fusion trees with corresponding block values:</p>
<div class="figure align-default" id="u1-fusiontrees">
<a class="reference internal image-reference" href="../_images/U1_fusiontrees.svg"><img alt="../_images/U1_fusiontrees.svg" height="134" src="../_images/U1_fusiontrees.svg" width="750" /></a>
</div>
<p>This gives us all the information necessary to construct the corresponding <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>s. We follow the same steps as outlined in the previous example, starting with the construction of the physical space. This will now be a <span class="math notranslate nohighlight">\(\mathrm{U}(1)\)</span> graded vector space <code class="docutils literal notranslate"><span class="pre">U1Space</span></code>, where each basis state <span class="math notranslate nohighlight">\(\ket{n}\)</span> in the occupation number basis is represented by the corresponding <span class="math notranslate nohighlight">\(\mathrm{U}(1)\)</span> irrep <code class="docutils literal notranslate"><span class="pre">U1Irrep(n)</span></code> with degeneracy 1. While this physical space is in principle infinite dimensional, we will impose a cutoff in occupation number at a maximum of 5 bosons per site, giving a 6-dimensional vector space:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">cutoff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span>
<span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">U1Space</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">:</span><span class="n">cutoff</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Rep[U₁](0=&gt;1, 1=&gt;1, 2=&gt;1, 3=&gt;1, 4=&gt;1, 5=&gt;1)
</pre></div>
</div>
</div>
</div>
<p>We can now initialize the <span class="math notranslate nohighlight">\(a^+ a^-\)</span>, <span class="math notranslate nohighlight">\(a^- a^+\)</span> and <span class="math notranslate nohighlight">\(N\)</span> operators as empty <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>s with the correct domain and codomain vector spaces, and fill in the nonzero blocks associated to <a class="reference internal" href="#u1-fusiontrees"><span class="std std-ref">the fusion trees shown above</span></a>. To do this we need access to the integer label of the <span class="math notranslate nohighlight">\(\mathrm{U}(1)\)</span> irreps in the fusion and splitting trees, which can be accessed through the <code class="docutils literal notranslate"><span class="pre">charge</span></code> field of the <code class="docutils literal notranslate"><span class="pre">U1Irrep</span></code> type.</p>
<div class="cell tag_hide-output docutils container">
<div class="cell_input above-output-prompt docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">a⁺a⁻</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">a⁺a⁻</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">s</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">only</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">U1Irrep</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">only</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">U1Irrep</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="w">        </span><span class="n">a⁺a⁻</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">charge</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">charge</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
<span class="n">a⁺a⁻</span>
</pre></div>
</div>
</div>
<details class="hide below-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell output</span>
<span class="expanded">Hide code cell output</span>
</summary>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap((Rep[U₁](0=&gt;1, 1=&gt;1, 2=&gt;1, 3=&gt;1, 4=&gt;1, 5=&gt;1) ⊗ Rep[U₁](0=&gt;1, 1=&gt;1, 2=&gt;1, 3=&gt;1, 4=&gt;1, 5=&gt;1)) ← (Rep[U₁](0=&gt;1, 1=&gt;1, 2=&gt;1, 3=&gt;1, 4=&gt;1, 5=&gt;1) ⊗ Rep[U₁](0=&gt;1, 1=&gt;1, 2=&gt;1, 3=&gt;1, 4=&gt;1, 5=&gt;1))):
* Data for sector (Irrep[U₁](0), Irrep[U₁](0)) ← (Irrep[U₁](0), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](0)) ← (Irrep[U₁](1), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](1)) ← (Irrep[U₁](1), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](0)) ← (Irrep[U₁](0), Irrep[U₁](1)):
[:, :, 1, 1] =
 1.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](1)) ← (Irrep[U₁](0), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](0)) ← (Irrep[U₁](2), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](1)) ← (Irrep[U₁](2), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](2)) ← (Irrep[U₁](2), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](0)) ← (Irrep[U₁](1), Irrep[U₁](1)):
[:, :, 1, 1] =
 1.4142135623730951 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](1)) ← (Irrep[U₁](1), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](2)) ← (Irrep[U₁](1), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](0)) ← (Irrep[U₁](0), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](1)) ← (Irrep[U₁](0), Irrep[U₁](2)):
[:, :, 1, 1] =
 1.4142135623730951 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](2)) ← (Irrep[U₁](0), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](3)) ← (Irrep[U₁](0), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](0)) ← (Irrep[U₁](0), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](1)) ← (Irrep[U₁](0), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](2)) ← (Irrep[U₁](0), Irrep[U₁](3)):
[:, :, 1, 1] =
 1.7320508075688772 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](3)) ← (Irrep[U₁](3), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](0)) ← (Irrep[U₁](3), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](1)) ← (Irrep[U₁](3), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](2)) ← (Irrep[U₁](3), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](3)) ← (Irrep[U₁](2), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](0)) ← (Irrep[U₁](2), Irrep[U₁](1)):
[:, :, 1, 1] =
 1.7320508075688772 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](1)) ← (Irrep[U₁](2), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](2)) ← (Irrep[U₁](2), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](3)) ← (Irrep[U₁](1), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](0)) ← (Irrep[U₁](1), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](1)) ← (Irrep[U₁](1), Irrep[U₁](2)):
[:, :, 1, 1] =
 2.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](2)) ← (Irrep[U₁](1), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](2)) ← (Irrep[U₁](2), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](1)) ← (Irrep[U₁](2), Irrep[U₁](2)):
[:, :, 1, 1] =
 2.449489742783178 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](4)) ← (Irrep[U₁](2), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](3)) ← (Irrep[U₁](2), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](0)) ← (Irrep[U₁](2), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](2)) ← (Irrep[U₁](3), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](1)) ← (Irrep[U₁](3), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](4)) ← (Irrep[U₁](3), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](3)) ← (Irrep[U₁](3), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](0)) ← (Irrep[U₁](3), Irrep[U₁](1)):
[:, :, 1, 1] =
 2.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](2)) ← (Irrep[U₁](0), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](1)) ← (Irrep[U₁](0), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](4)) ← (Irrep[U₁](0), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](3)) ← (Irrep[U₁](0), Irrep[U₁](4)):
[:, :, 1, 1] =
 2.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](0)) ← (Irrep[U₁](0), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](2)) ← (Irrep[U₁](1), Irrep[U₁](3)):
[:, :, 1, 1] =
 2.449489742783178 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](1)) ← (Irrep[U₁](1), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](4)) ← (Irrep[U₁](1), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](3)) ← (Irrep[U₁](1), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](0)) ← (Irrep[U₁](1), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](2)) ← (Irrep[U₁](4), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](1)) ← (Irrep[U₁](4), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](4)) ← (Irrep[U₁](4), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](3)) ← (Irrep[U₁](4), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](0)) ← (Irrep[U₁](4), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](0)) ← (Irrep[U₁](5), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](3)) ← (Irrep[U₁](5), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](5)) ← (Irrep[U₁](5), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](1)) ← (Irrep[U₁](5), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](2)) ← (Irrep[U₁](5), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](4)) ← (Irrep[U₁](5), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](0)) ← (Irrep[U₁](2), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](3)) ← (Irrep[U₁](2), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](5)) ← (Irrep[U₁](2), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](1)) ← (Irrep[U₁](2), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](2)) ← (Irrep[U₁](2), Irrep[U₁](3)):
[:, :, 1, 1] =
 3.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](4)) ← (Irrep[U₁](2), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](0)) ← (Irrep[U₁](0), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](3)) ← (Irrep[U₁](0), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](5)) ← (Irrep[U₁](0), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](1)) ← (Irrep[U₁](0), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](2)) ← (Irrep[U₁](0), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](4)) ← (Irrep[U₁](0), Irrep[U₁](5)):
[:, :, 1, 1] =
 2.23606797749979 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](0)) ← (Irrep[U₁](4), Irrep[U₁](1)):
[:, :, 1, 1] =
 2.23606797749979 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](3)) ← (Irrep[U₁](4), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](5)) ← (Irrep[U₁](4), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](1)) ← (Irrep[U₁](4), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](2)) ← (Irrep[U₁](4), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](4)) ← (Irrep[U₁](4), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](0)) ← (Irrep[U₁](3), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](3)) ← (Irrep[U₁](3), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](5)) ← (Irrep[U₁](3), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](1)) ← (Irrep[U₁](3), Irrep[U₁](2)):
[:, :, 1, 1] =
 2.8284271247461903 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](2)) ← (Irrep[U₁](3), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](4)) ← (Irrep[U₁](3), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](0)) ← (Irrep[U₁](1), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](3)) ← (Irrep[U₁](1), Irrep[U₁](4)):
[:, :, 1, 1] =
 2.8284271247461903 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](5)) ← (Irrep[U₁](1), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](1)) ← (Irrep[U₁](1), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](2)) ← (Irrep[U₁](1), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](4)) ← (Irrep[U₁](1), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](1)) ← (Irrep[U₁](5), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](3)) ← (Irrep[U₁](5), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](4)) ← (Irrep[U₁](5), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](5)) ← (Irrep[U₁](5), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](2)) ← (Irrep[U₁](5), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](1)) ← (Irrep[U₁](3), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](3)) ← (Irrep[U₁](3), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](4)) ← (Irrep[U₁](3), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](5)) ← (Irrep[U₁](3), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](2)) ← (Irrep[U₁](3), Irrep[U₁](3)):
[:, :, 1, 1] =
 3.4641016151377544 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](1)) ← (Irrep[U₁](2), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](3)) ← (Irrep[U₁](2), Irrep[U₁](4)):
[:, :, 1, 1] =
 3.4641016151377544 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](4)) ← (Irrep[U₁](2), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](5)) ← (Irrep[U₁](2), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](2)) ← (Irrep[U₁](2), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](1)) ← (Irrep[U₁](1), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](3)) ← (Irrep[U₁](1), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](4)) ← (Irrep[U₁](1), Irrep[U₁](5)):
[:, :, 1, 1] =
 3.1622776601683795 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](5)) ← (Irrep[U₁](1), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](2)) ← (Irrep[U₁](1), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](1)) ← (Irrep[U₁](4), Irrep[U₁](2)):
[:, :, 1, 1] =
 3.1622776601683795 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](3)) ← (Irrep[U₁](4), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](4)) ← (Irrep[U₁](4), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](5)) ← (Irrep[U₁](4), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](2)) ← (Irrep[U₁](4), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](5)) ← (Irrep[U₁](2), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](3)) ← (Irrep[U₁](2), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](4)) ← (Irrep[U₁](2), Irrep[U₁](5)):
[:, :, 1, 1] =
 3.872983346207417 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](2)) ← (Irrep[U₁](2), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](5)) ← (Irrep[U₁](4), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](3)) ← (Irrep[U₁](4), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](4)) ← (Irrep[U₁](4), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](2)) ← (Irrep[U₁](4), Irrep[U₁](3)):
[:, :, 1, 1] =
 3.872983346207417 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](5)) ← (Irrep[U₁](3), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](3)) ← (Irrep[U₁](3), Irrep[U₁](4)):
[:, :, 1, 1] =
 4.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](4)) ← (Irrep[U₁](3), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](2)) ← (Irrep[U₁](3), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](5)) ← (Irrep[U₁](5), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](3)) ← (Irrep[U₁](5), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](4)) ← (Irrep[U₁](5), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](2)) ← (Irrep[U₁](5), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](3)) ← (Irrep[U₁](5), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](5)) ← (Irrep[U₁](5), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](4)) ← (Irrep[U₁](5), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](3)) ← (Irrep[U₁](3), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](5)) ← (Irrep[U₁](3), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](4)) ← (Irrep[U₁](3), Irrep[U₁](5)):
[:, :, 1, 1] =
 4.47213595499958 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](3)) ← (Irrep[U₁](4), Irrep[U₁](4)):
[:, :, 1, 1] =
 4.47213595499958 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](5)) ← (Irrep[U₁](4), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](4)) ← (Irrep[U₁](4), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](4)) ← (Irrep[U₁](5), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](5)) ← (Irrep[U₁](5), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](4)) ← (Irrep[U₁](4), Irrep[U₁](5)):
[:, :, 1, 1] =
 5.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](5)) ← (Irrep[U₁](4), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](5)) ← (Irrep[U₁](5), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
</pre></div>
</div>
</div>
</details>
</div>
<div class="cell tag_hide-output docutils container">
<div class="cell_input above-output-prompt docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">a⁻a⁺</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">a⁻a⁺</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">s</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">only</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">U1Irrep</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">only</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">U1Irrep</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="w">        </span><span class="n">a⁻a⁺</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">charge</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">charge</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
<span class="n">a⁻a⁺</span>
</pre></div>
</div>
</div>
<details class="hide below-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell output</span>
<span class="expanded">Hide code cell output</span>
</summary>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap((Rep[U₁](0=&gt;1, 1=&gt;1, 2=&gt;1, 3=&gt;1, 4=&gt;1, 5=&gt;1) ⊗ Rep[U₁](0=&gt;1, 1=&gt;1, 2=&gt;1, 3=&gt;1, 4=&gt;1, 5=&gt;1)) ← (Rep[U₁](0=&gt;1, 1=&gt;1, 2=&gt;1, 3=&gt;1, 4=&gt;1, 5=&gt;1) ⊗ Rep[U₁](0=&gt;1, 1=&gt;1, 2=&gt;1, 3=&gt;1, 4=&gt;1, 5=&gt;1))):
* Data for sector (Irrep[U₁](0), Irrep[U₁](0)) ← (Irrep[U₁](0), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](0)) ← (Irrep[U₁](1), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](1)) ← (Irrep[U₁](1), Irrep[U₁](0)):
[:, :, 1, 1] =
 1.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](0)) ← (Irrep[U₁](0), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](1)) ← (Irrep[U₁](0), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](0)) ← (Irrep[U₁](2), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](1)) ← (Irrep[U₁](2), Irrep[U₁](0)):
[:, :, 1, 1] =
 1.4142135623730951 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](2)) ← (Irrep[U₁](2), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](0)) ← (Irrep[U₁](1), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](1)) ← (Irrep[U₁](1), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](2)) ← (Irrep[U₁](1), Irrep[U₁](1)):
[:, :, 1, 1] =
 1.4142135623730951 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](0)) ← (Irrep[U₁](0), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](1)) ← (Irrep[U₁](0), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](2)) ← (Irrep[U₁](0), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](3)) ← (Irrep[U₁](0), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](0)) ← (Irrep[U₁](0), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](1)) ← (Irrep[U₁](0), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](2)) ← (Irrep[U₁](0), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](3)) ← (Irrep[U₁](3), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](0)) ← (Irrep[U₁](3), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](1)) ← (Irrep[U₁](3), Irrep[U₁](0)):
[:, :, 1, 1] =
 1.7320508075688772 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](2)) ← (Irrep[U₁](3), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](3)) ← (Irrep[U₁](2), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](0)) ← (Irrep[U₁](2), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](1)) ← (Irrep[U₁](2), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](2)) ← (Irrep[U₁](2), Irrep[U₁](1)):
[:, :, 1, 1] =
 2.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](3)) ← (Irrep[U₁](1), Irrep[U₁](2)):
[:, :, 1, 1] =
 1.7320508075688772 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](0)) ← (Irrep[U₁](1), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](1)) ← (Irrep[U₁](1), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](2)) ← (Irrep[U₁](1), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](2)) ← (Irrep[U₁](2), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](1)) ← (Irrep[U₁](2), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](4)) ← (Irrep[U₁](2), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](3)) ← (Irrep[U₁](2), Irrep[U₁](2)):
[:, :, 1, 1] =
 2.449489742783178 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](0)) ← (Irrep[U₁](2), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](2)) ← (Irrep[U₁](3), Irrep[U₁](1)):
[:, :, 1, 1] =
 2.449489742783178 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](1)) ← (Irrep[U₁](3), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](4)) ← (Irrep[U₁](3), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](3)) ← (Irrep[U₁](3), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](0)) ← (Irrep[U₁](3), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](2)) ← (Irrep[U₁](0), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](1)) ← (Irrep[U₁](0), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](4)) ← (Irrep[U₁](0), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](3)) ← (Irrep[U₁](0), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](0)) ← (Irrep[U₁](0), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](2)) ← (Irrep[U₁](1), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](1)) ← (Irrep[U₁](1), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](4)) ← (Irrep[U₁](1), Irrep[U₁](3)):
[:, :, 1, 1] =
 2.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](3)) ← (Irrep[U₁](1), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](0)) ← (Irrep[U₁](1), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](2)) ← (Irrep[U₁](4), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](1)) ← (Irrep[U₁](4), Irrep[U₁](0)):
[:, :, 1, 1] =
 2.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](4)) ← (Irrep[U₁](4), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](3)) ← (Irrep[U₁](4), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](0)) ← (Irrep[U₁](4), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](0)) ← (Irrep[U₁](5), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](3)) ← (Irrep[U₁](5), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](5)) ← (Irrep[U₁](5), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](1)) ← (Irrep[U₁](5), Irrep[U₁](0)):
[:, :, 1, 1] =
 2.23606797749979 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](2)) ← (Irrep[U₁](5), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](4)) ← (Irrep[U₁](5), Irrep[U₁](0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](0)) ← (Irrep[U₁](2), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](3)) ← (Irrep[U₁](2), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](5)) ← (Irrep[U₁](2), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](1)) ← (Irrep[U₁](2), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](2)) ← (Irrep[U₁](2), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](4)) ← (Irrep[U₁](2), Irrep[U₁](3)):
[:, :, 1, 1] =
 2.8284271247461903 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](0)) ← (Irrep[U₁](0), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](3)) ← (Irrep[U₁](0), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](5)) ← (Irrep[U₁](0), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](1)) ← (Irrep[U₁](0), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](2)) ← (Irrep[U₁](0), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](4)) ← (Irrep[U₁](0), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](0)) ← (Irrep[U₁](4), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](3)) ← (Irrep[U₁](4), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](5)) ← (Irrep[U₁](4), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](1)) ← (Irrep[U₁](4), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](2)) ← (Irrep[U₁](4), Irrep[U₁](1)):
[:, :, 1, 1] =
 2.8284271247461903 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](4)) ← (Irrep[U₁](4), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](0)) ← (Irrep[U₁](3), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](3)) ← (Irrep[U₁](3), Irrep[U₁](2)):
[:, :, 1, 1] =
 3.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](5)) ← (Irrep[U₁](3), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](1)) ← (Irrep[U₁](3), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](2)) ← (Irrep[U₁](3), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](4)) ← (Irrep[U₁](3), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](0)) ← (Irrep[U₁](1), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](3)) ← (Irrep[U₁](1), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](0), Irrep[U₁](5)) ← (Irrep[U₁](1), Irrep[U₁](4)):
[:, :, 1, 1] =
 2.23606797749979 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](1)) ← (Irrep[U₁](1), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](2)) ← (Irrep[U₁](1), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](4)) ← (Irrep[U₁](1), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](1)) ← (Irrep[U₁](5), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](3)) ← (Irrep[U₁](5), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](4)) ← (Irrep[U₁](5), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](5)) ← (Irrep[U₁](5), Irrep[U₁](1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](2)) ← (Irrep[U₁](5), Irrep[U₁](1)):
[:, :, 1, 1] =
 3.1622776601683795 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](1)) ← (Irrep[U₁](3), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](3)) ← (Irrep[U₁](3), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](4)) ← (Irrep[U₁](3), Irrep[U₁](3)):
[:, :, 1, 1] =
 3.4641016151377544 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](5)) ← (Irrep[U₁](3), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](2)) ← (Irrep[U₁](3), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](1)) ← (Irrep[U₁](2), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](3)) ← (Irrep[U₁](2), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](4)) ← (Irrep[U₁](2), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](5)) ← (Irrep[U₁](2), Irrep[U₁](4)):
[:, :, 1, 1] =
 3.1622776601683795 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](2)) ← (Irrep[U₁](2), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](1)) ← (Irrep[U₁](1), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](3)) ← (Irrep[U₁](1), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](4)) ← (Irrep[U₁](1), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](5)) ← (Irrep[U₁](1), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](2)) ← (Irrep[U₁](1), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](1)) ← (Irrep[U₁](4), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](3)) ← (Irrep[U₁](4), Irrep[U₁](2)):
[:, :, 1, 1] =
 3.4641016151377544 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](4)) ← (Irrep[U₁](4), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](5)) ← (Irrep[U₁](4), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](2)) ← (Irrep[U₁](4), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](5)) ← (Irrep[U₁](2), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](3)) ← (Irrep[U₁](2), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](4)) ← (Irrep[U₁](2), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](2)) ← (Irrep[U₁](2), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](5)) ← (Irrep[U₁](4), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](3)) ← (Irrep[U₁](4), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](4)) ← (Irrep[U₁](4), Irrep[U₁](3)):
[:, :, 1, 1] =
 4.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](2)) ← (Irrep[U₁](4), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](5)) ← (Irrep[U₁](3), Irrep[U₁](4)):
[:, :, 1, 1] =
 3.872983346207417 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](3)) ← (Irrep[U₁](3), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](4)) ← (Irrep[U₁](3), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](2)) ← (Irrep[U₁](3), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](2), Irrep[U₁](5)) ← (Irrep[U₁](5), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](3)) ← (Irrep[U₁](5), Irrep[U₁](2)):
[:, :, 1, 1] =
 3.872983346207417 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](4)) ← (Irrep[U₁](5), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](2)) ← (Irrep[U₁](5), Irrep[U₁](2)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](3)) ← (Irrep[U₁](5), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](5)) ← (Irrep[U₁](5), Irrep[U₁](3)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](4)) ← (Irrep[U₁](5), Irrep[U₁](3)):
[:, :, 1, 1] =
 4.47213595499958 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](3)) ← (Irrep[U₁](3), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](5)) ← (Irrep[U₁](3), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](4)) ← (Irrep[U₁](3), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](3)) ← (Irrep[U₁](4), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](3), Irrep[U₁](5)) ← (Irrep[U₁](4), Irrep[U₁](4)):
[:, :, 1, 1] =
 4.47213595499958 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](4)) ← (Irrep[U₁](4), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](4)) ← (Irrep[U₁](5), Irrep[U₁](4)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](5)) ← (Irrep[U₁](5), Irrep[U₁](4)):
[:, :, 1, 1] =
 5.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](4)) ← (Irrep[U₁](4), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](4), Irrep[U₁](5)) ← (Irrep[U₁](4), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (Irrep[U₁](5), Irrep[U₁](5)) ← (Irrep[U₁](5), Irrep[U₁](5)):
[:, :, 1, 1] =
 0.0 + 0.0im
</pre></div>
</div>
</div>
</details>
</div>
<div class="cell tag_hide-output docutils container">
<div class="cell_input above-output-prompt docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="w">    </span><span class="n">N</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">charge</span>
<span class="k">end</span>
<span class="n">N</span>
</pre></div>
</div>
</div>
<details class="hide below-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell output</span>
<span class="expanded">Hide code cell output</span>
</summary>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap(Rep[U₁](0=&gt;1, 1=&gt;1, 2=&gt;1, 3=&gt;1, 4=&gt;1, 5=&gt;1) ← Rep[U₁](0=&gt;1, 1=&gt;1, 2=&gt;1, 3=&gt;1, 4=&gt;1, 5=&gt;1)):
* Data for sector (Irrep[U₁](0),) ← (Irrep[U₁](0),):
 0.0 + 0.0im
* Data for sector (Irrep[U₁](1),) ← (Irrep[U₁](1),):
 1.0 + 0.0im
* Data for sector (Irrep[U₁](2),) ← (Irrep[U₁](2),):
 2.0 + 0.0im
* Data for sector (Irrep[U₁](3),) ← (Irrep[U₁](3),):
 3.0 + 0.0im
* Data for sector (Irrep[U₁](4),) ← (Irrep[U₁](4),):
 4.0 + 0.0im
* Data for sector (Irrep[U₁](5),) ← (Irrep[U₁](5),):
 5.0 + 0.0im
</pre></div>
</div>
</div>
</details>
</div>
</div>
<div class="section" id="creation-and-annihilation-operators-as-symmetric-tensors">
<h3><span class="section-number">18.3.2. </span>Creation and Annihilation Operators as Symmetric Tensors<a class="headerlink" href="#creation-and-annihilation-operators-as-symmetric-tensors" title="Permalink to this heading">#</a></h3>
<p>Just as in the <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> case, it is obvious that we cannot directly construct the creation and annihilation operators as instances of a <code class="docutils literal notranslate"><span class="pre">TensorMap(...,</span> <span class="pre">V</span> <span class="pre">←</span> <span class="pre">V)</span></code> since they are not invariant under conjugation by the symmetry operator. However, it is possible to construct them as <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>s using an <em>auxiliary vector space</em>, based on the following intuition. The creation operator <span class="math notranslate nohighlight">\(a^+\)</span> violates particle number conservation by mapping the occupation number <span class="math notranslate nohighlight">\(n\)</span> to <span class="math notranslate nohighlight">\(n + 1\)</span>. From the point of view of representation theory, this process can be thought af the <em>fusion</em> of an <code class="docutils literal notranslate"><span class="pre">U1Irrep(n)</span></code> with an <code class="docutils literal notranslate"><span class="pre">U1Irrep(1)</span></code>, naturally giving the fusion product <code class="docutils literal notranslate"><span class="pre">U1Irrep(n</span> <span class="pre">+</span> <span class="pre">1)</span></code>. This means we can represent <span class="math notranslate nohighlight">\(a^+\)</span> as a <code class="docutils literal notranslate"><span class="pre">TensorMap(...,</span> <span class="pre">V</span> <span class="pre">←</span> <span class="pre">V</span> <span class="pre">⊗</span> <span class="pre">A)</span></code>, where the auxiliary vector space <code class="docutils literal notranslate"><span class="pre">A</span></code> is contains the <span class="math notranslate nohighlight">\(+1\)</span> irrep with degeneracy 1,  <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">U1Space(1</span> <span class="pre">=&gt;</span> <span class="pre">1)</span></code>. Similarly, the decrease in occupation number when acting with <span class="math notranslate nohighlight">\(a^-\)</span> can be thought of as the <em>splitting</em> of an <code class="docutils literal notranslate"><span class="pre">U1Irrep(n)</span></code> into an <code class="docutils literal notranslate"><span class="pre">U1Irrep(n</span> <span class="pre">-</span> <span class="pre">1)</span></code> and an <code class="docutils literal notranslate"><span class="pre">U1Irrep(1)</span></code>, leading to a representation in terms of a <code class="docutils literal notranslate"><span class="pre">TensorMap(...,</span> <span class="pre">A</span> <span class="pre">⊗</span> <span class="pre">V</span> <span class="pre">←</span> <span class="pre">V)</span></code>. Based on these observations, we can represent the matrix elements <a class="reference internal" href="#equation-eq-bosonopmatel">(18.4)</a> as blocks labeled by the <span class="math notranslate nohighlight">\(\mathrm{U}(1)\)</span> fusion trees</p>
<div class="figure align-default" id="bosonops">
<a class="reference internal image-reference" href="../_images/bosonops.svg"><img alt="../_images/bosonops.svg" height="105" src="../_images/bosonops.svg" width="768" /></a>
</div>
<p>We can then combine these operators in to get the appropriate Hamiltonian terms,</p>
<div class="figure align-default" id="bosonham">
<a class="reference internal image-reference" href="../_images/bosonham.svg"><img alt="../_images/bosonham.svg" height="107" src="../_images/bosonham.svg" width="512" /></a>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although we have made a suggestive distinction between the ‘left’ and ‘right’ versions of the operators <span class="math notranslate nohighlight">\(a_L^\pm\)</span> and <span class="math notranslate nohighlight">\(a_R^\pm\)</span>, one can actually be obtained from the other by permuting the physical and auxiliary indices of the corresponding <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>s. This permutation has no effect on the actual array blocks of the tensors due to the <a class="reference external" href="https://jutho.github.io/TensorKit.jl/latest/lib/sectors/#TensorKit.BraidingStyle">bosonic braiding style</a> of <span class="math notranslate nohighlight">\(\mathrm{U}(1)\)</span> irreps, so the left and right operators can in essence by seen as the ‘same’ tensors. This is no longer the case when considering fermionic systems, where permuting indices can in fact change the array blocks as we will see next. As consequence, it is much less clear how to construct two-site symmetric operators in terms of local symmetric objects.</p>
</div>
<p>The explicit construction then looks something like</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">U1Space</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Rep[U₁](1=&gt;1)
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-output docutils container">
<div class="cell_input above-output-prompt docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">a⁺</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">A</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">a⁺</span><span class="p">)</span>
<span class="w">    </span><span class="n">a⁺</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">charge</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="k">end</span>
<span class="n">a⁺</span>
</pre></div>
</div>
</div>
<details class="hide below-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell output</span>
<span class="expanded">Hide code cell output</span>
</summary>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap(Rep[U₁](0=&gt;1, 1=&gt;1, 2=&gt;1, 3=&gt;1, 4=&gt;1, 5=&gt;1) ← (Rep[U₁](0=&gt;1, 1=&gt;1, 2=&gt;1, 3=&gt;1, 4=&gt;1, 5=&gt;1) ⊗ Rep[U₁](1=&gt;1))):
* Data for sector (Irrep[U₁](1),) ← (Irrep[U₁](0), Irrep[U₁](1)):
[:, :, 1] =
 1.0 + 0.0im
* Data for sector (Irrep[U₁](2),) ← (Irrep[U₁](1), Irrep[U₁](1)):
[:, :, 1] =
 1.4142135623730951 + 0.0im
* Data for sector (Irrep[U₁](3),) ← (Irrep[U₁](2), Irrep[U₁](1)):
[:, :, 1] =
 1.7320508075688772 + 0.0im
* Data for sector (Irrep[U₁](4),) ← (Irrep[U₁](3), Irrep[U₁](1)):
[:, :, 1] =
 2.0 + 0.0im
* Data for sector (Irrep[U₁](5),) ← (Irrep[U₁](4), Irrep[U₁](1)):
[:, :, 1] =
 2.23606797749979 + 0.0im
</pre></div>
</div>
</div>
</details>
</div>
<div class="cell tag_hide-output docutils container">
<div class="cell_input above-output-prompt docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">a⁻</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">a⁻</span><span class="p">)</span>
<span class="w">    </span><span class="n">a⁻</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">charge</span><span class="p">)</span>
<span class="k">end</span>
<span class="n">a⁻</span>
</pre></div>
</div>
</div>
<details class="hide below-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell output</span>
<span class="expanded">Hide code cell output</span>
</summary>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap((Rep[U₁](1=&gt;1) ⊗ Rep[U₁](0=&gt;1, 1=&gt;1, 2=&gt;1, 3=&gt;1, 4=&gt;1, 5=&gt;1)) ← Rep[U₁](0=&gt;1, 1=&gt;1, 2=&gt;1, 3=&gt;1, 4=&gt;1, 5=&gt;1)):
* Data for sector (Irrep[U₁](1), Irrep[U₁](0)) ← (Irrep[U₁](1),):
[:, :, 1] =
 1.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](1)) ← (Irrep[U₁](2),):
[:, :, 1] =
 1.4142135623730951 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](2)) ← (Irrep[U₁](3),):
[:, :, 1] =
 1.7320508075688772 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](3)) ← (Irrep[U₁](4),):
[:, :, 1] =
 2.0 + 0.0im
* Data for sector (Irrep[U₁](1), Irrep[U₁](4)) ← (Irrep[U₁](5),):
[:, :, 1] =
 2.23606797749979 + 0.0im
</pre></div>
</div>
</div>
</details>
</div>
<p>It is then simple to check that this is indeed what we expect.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@tensor</span><span class="w"> </span><span class="n">a⁺a⁻_bis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a⁺</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a⁻</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
<span class="nd">@tensor</span><span class="w"> </span><span class="n">a⁻a⁺_bis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a⁻</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a⁺</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span>
<span class="nd">@tensor</span><span class="w"> </span><span class="n">N_bis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a⁺</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a⁻</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

<span class="nd">@test</span><span class="w"> </span><span class="n">norm</span><span class="p">(</span><span class="n">a⁺a⁻_bis</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a⁺a⁻</span><span class="p">)</span><span class="w"> </span><span class="o">≈</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span>
<span class="nd">@test</span><span class="w"> </span><span class="n">norm</span><span class="p">(</span><span class="n">a⁻a⁺_bis</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a⁻a⁺</span><span class="p">)</span><span class="w"> </span><span class="o">≈</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span>
<span class="nd">@test</span><span class="w"> </span><span class="n">norm</span><span class="p">(</span><span class="n">N_bis</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">≈</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span><span class=" -Color -Color-Bold -Color-Bold-Green">Test Passed</span>
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>From the construction of the Hamiltonian operators <a class="reference internal" href="#bosonham"><span class="std std-ref">in terms of creation and annihilation operators</span></a> we clearly see that they are invariant under a transformation <span class="math notranslate nohighlight">\(a^\pm \to e^{\pm i\theta} a^\pm\)</span>. More generally, any invertible transformation on the auxiliary space leaves the resulting contraction unchanged. This ambiguity in the definition clearly shows that one should really always think in terms of the fully symmetric procucts of <span class="math notranslate nohighlight">\(a^+\)</span> and <span class="math notranslate nohighlight">\(a^-\)</span> rather than in terms of these operators themselves. In particular, one can always decompose such a symmetric product into the <a class="reference internal" href="#bosonham"><span class="std std-ref">form above</span></a> by means of an SVD.</p>
</div>
</div>
</div>
<div class="section" id="level-3-fermions-and-the-kitaev-model">
<h2><span class="section-number">18.4. </span>Level 3: Fermions and the Kitaev Model<a class="headerlink" href="#level-3-fermions-and-the-kitaev-model" title="Permalink to this heading">#</a></h2>
<p>While we have already covered quite a lot of ground towards understanding symmetric tensors in terms of fusion trees and corresponding blocks, the symmetries considered so far have been quite ‘simple’ in the sense that sectors corresponding to irreps of <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> and <span class="math notranslate nohighlight">\(\mathrm{U}(1)\)</span> have <a class="reference external" href="https://jutho.github.io/TensorKit.jl/latest/lib/sectors/#TensorKit.FusionStyle"><em>Abelian fusion rules</em></a> and <a class="reference external" href="https://jutho.github.io/TensorKit.jl/latest/lib/sectors/#TensorKit.BraidingStyle"><em>bosonic exchange statistics</em></a>. This means that the fusion of two irreps always gives a single irrep as the fusion product, and that exchanging two irreps in a tensor product is trivial. In practice, this implies that for tensors with these symmetries the fusion trees are completely fixed by the uncoupled charges, which uniquely define both the inner line and the coupled charge, and that tensor indices can be permuted freely without any ‘strange’ side effects.</p>
<p>In the following we will consider examples with fermionic and even anyonic exchange statistics, and non-Abelian fusion rules. In going through these examples it will become clear that the fusion trees labeling the blocks of a symmetric tensor imply more information than just a labeling.</p>
<div class="section" id="fermion-parity-symmetry">
<h3><span class="section-number">18.4.1. </span>Fermion Parity Symmetry<a class="headerlink" href="#fermion-parity-symmetry" title="Permalink to this heading">#</a></h3>
<p>As a simple example we will consider the Kitaev chain, which describes a chain of interacting spinless fermions with nearest-neighbor hopping and pairing terms. The Hamiltonian of this model is given by</p>
<div class="math notranslate nohighlight" id="equation-eq-kitaev">
<span class="eqno">(18.5)<a class="headerlink" href="#equation-eq-kitaev" title="Permalink to this equation">#</a></span>\[H = \sum_{\langle i,j \rangle} \left(-\frac{t}{2}(c_i^+ c_j^- - c_i^- c_j^+) + \frac{\Delta}{2}(c_i^+ c_j^+ - c_i^- c_j^-) \right) - \mu \sum_{i} N_i\]</div>
<p>where <span class="math notranslate nohighlight">\(N_i = c_i^+ c_i^-\)</span> is the local particle number operator. As opposed to the previous case, the fermionic creation and annihilation operators now satisfy the anticommutation relations</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\left\{c_i^-, c_j^-\right\} &amp;= \left\{c_i^+, c_j^+\right\} = 0 \\
\left\{c_i^-, c_j^+\right\} &amp;= \delta_{ij} .\\
\end{align*}\end{split}\]</div>
<p>These commutation relations justify the choice of the relative minus sign in the hopping and pairing terms. Indeed, since fermionic operators on different sites always anticommute, these relative minus signs are needed to ensure that the Hamiltonian is Hermitian, since <span class="math notranslate nohighlight">\(\left( c_i^+ c_j^- \right)^\dagger = c_j^+ c_i^- = - c_i^- c_j^+\)</span> and <span class="math notranslate nohighlight">\(\left( c_i^+ c_j^+ \right)^\dagger = c_j^- c_i^- = - c_i^- c_j^-\)</span>.
The anticommutation relations also naturally restrict the local occupation number to be 0 or 1, leading to a well-defined notion of <em>fermion-parity</em>. The local fermion-parity operator is related to the fermion number operator as <span class="math notranslate nohighlight">\(Q_i = (-1)^{n_i}\)</span>, and is diagonal in the occupation number basis. The Hamiltonian <a class="reference internal" href="#equation-eq-kitaev">(18.5)</a> is invariant under conjugation by the global fermion-parity operator, <span class="math notranslate nohighlight">\(Q H Q^\dagger = H\)</span>, where</p>
<div class="math notranslate nohighlight">
\[Q = \exp \left( i \pi \sum_i N_i \right) = (-1)^{\sum_i N_i}.\]</div>
<p>This fermion parity symmetry, which we will denote as <span class="math notranslate nohighlight">\(f\mathbb{Z}_2\)</span>, is a <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span>-like symmetry in the sense that it has a trivial representation, which we call <em>even</em> and again denote by ‘0’, and a sign representation which we call <em>odd</em> and denote by ‘1’. The fusion rules of these irreps are the same as for <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span>. Similar to the previous case, the local symmetry operator <span class="math notranslate nohighlight">\(Q_i\)</span> is already diagonal, so the occupation number basis coincides with the irrep basis and we don’t need an additional basis transform. The important difference with a regular <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> symmetry is that the irreps of <span class="math notranslate nohighlight">\(f\mathbb{Z}_2\)</span> have fermionic braiding statistics, in the sense that exhanging two odd irreps gives rise to a minus sign.</p>
<p>In TensorKit.jl, an <span class="math notranslate nohighlight">\(f\mathbb{Z}_2\)</span>-graded vector spaces is represented as a <code class="docutils literal notranslate"><span class="pre">Vect[FermionParity]</span></code> space, where a given <span class="math notranslate nohighlight">\(f\mathbb{Z}_2\)</span> irrep can be represented as a <a class="reference external" href="https://jutho.github.io/TensorKit.jl/stable/lib/sectors/#TensorKit.FermionParity"><code class="docutils literal notranslate"><span class="pre">FermionParity</span></code></a> sector instance. Using the simplest instance of a vector space containing a single even and odd irrep, we can already demonstrate the corresponding fermionic braiding behavior by <a class="reference external" href="https://jutho.github.io/TensorKit.jl/stable/lib/tensors/#TensorKit.permute-Union%7BTuple%7BN%E2%82%82%7D,%20Tuple%7BN%E2%82%81%7D,%20Tuple%7BS%7D,%20Tuple%7BAbstractTensorMap%7BS%7D,%20Tuple%7BTuple%7BVararg%7BInt64,%20N%E2%82%81%7D%7D,%20Tuple%7BVararg%7BInt64,%20N%E2%82%82%7D%7D%7D%7D%7D%20where%20%7BS,%20N%E2%82%81,%20N%E2%82%82%7D">performing a permutation</a> on a simple <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vect</span><span class="p">[</span><span class="n">FermionParity</span><span class="p">](</span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap(Vect[FermionParity](0=&gt;1, 1=&gt;1) ← (Vect[FermionParity](0=&gt;1, 1=&gt;1) ⊗ Vect[FermionParity](0=&gt;1, 1=&gt;1))):
* Data for sector (FermionParity(0),) ← (FermionParity(0), FermionParity(0)):
[:, :, 1] =
 1.0 + 0.0im
* Data for sector (FermionParity(0),) ← (FermionParity(1), FermionParity(1)):
[:, :, 1] =
 1.0 + 0.0im
* Data for sector (FermionParity(1),) ← (FermionParity(1), FermionParity(0)):
[:, :, 1] =
 1.0 + 0.0im
* Data for sector (FermionParity(1),) ← (FermionParity(0), FermionParity(1)):
[:, :, 1] =
 1.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">permute</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap(Vect[FermionParity](0=&gt;1, 1=&gt;1) ← (Vect[FermionParity](0=&gt;1, 1=&gt;1) ⊗ Vect[FermionParity](0=&gt;1, 1=&gt;1))):
* Data for sector (FermionParity(0),) ← (FermionParity(0), FermionParity(0)):
[:, :, 1] =
 1.0 + 0.0im
* Data for sector (FermionParity(0),) ← (FermionParity(1), FermionParity(1)):
[:, :, 1] =
 -1.0 + 0.0im
* Data for sector (FermionParity(1),) ← (FermionParity(1), FermionParity(0)):
[:, :, 1] =
 1.0 + 0.0im
* Data for sector (FermionParity(1),) ← (FermionParity(0), FermionParity(1)):
[:, :, 1] =
 1.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<p>In other words, when exchanging the two domain vector spaces, the block of the <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> for which both corresponding irreps are odd picks up a minus sign, exactly as we would expect for fermionic charges.</p>
</div>
<div class="section" id="constructing-the-hamiltonian">
<h3><span class="section-number">18.4.2. </span>Constructing the Hamiltonian<a class="headerlink" href="#constructing-the-hamiltonian" title="Permalink to this heading">#</a></h3>
<p>We can directly construct the Hamiltonian terms as symmetric <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>s using the same procedure as before starting from their matrix elements in the occupation number basis. However, in this case we should be a bit more careful about the precise definition of the basis states in composite systems. Indeed, the tensor product structure of fermionic systems is inherently tricky to deal with, and should ideally be treated in the context of <a class="reference external" href="https://en.wikipedia.org/wiki/Super_vector_space"><em>super vector spaces</em></a>. For two sites, we can define the following basis states on top of the fermionic vacuuum <span class="math notranslate nohighlight">\(\ket{00}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\ket{01} &amp;= c_2^+ \ket{00} \\
\ket{10} &amp;= c_1^+ \ket{00} \\
\ket{11} &amp;= c_1^+ c_2^+ \ket{00} \\
\end{align*}\end{split}\]</div>
<p>This definition in combination with the anticommutation relations above give rise to the nonzero matrix elements</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
c_1^+ c_2^- \ket{0, 1} &amp;= \ket{1, 0} \\
c_1^- c_2^+ \ket{1, 0} &amp;= - \ket{0, 1} \\
c_1^+ c_2^+ \ket{0, 0} &amp;= \ket{1, 1} \\
c_1^- c_2^- \ket{1, 1} &amp;= - \ket{0, 0} \\
N \ket{n} &amp;= n \ket{n}.
\end{align*}\end{split}\]</div>
<p>While the signs in these expressions may seem a little unintuitive at first sight, they are essential to the fermionic nature of the system. Indeed, if we for example work out the matrix element of <span class="math notranslate nohighlight">\(c_1^- c_2^+\)</span> we find</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
c_1^- c_2^+ \ket{1, 0} = c_1^- c_2^+ c_1^+ \ket{0, 0} = - c_2^+ c_1^- c_1^+ \ket{0, 0} = - c_2^+ (\mathbb{1} - c_1^+ c_1^-) \ket{0, 0} = - c_2^+ \ket{0, 0} = - \ket{0, 1}. \\
\end{align*}\end{split}\]</div>
<p>Once we have these matrix elements the hard part is done, and we can naively associate these to the following <span class="math notranslate nohighlight">\(f\mathbb{Z}_2\)</span> fusion trees with corresponding block values,</p>
<div class="figure align-default" id="fz2-fusiontrees">
<a class="reference internal image-reference" href="../_images/fZ2_fusiontrees.svg"><img alt="../_images/fZ2_fusiontrees.svg" height="130" src="../_images/fZ2_fusiontrees.svg" width="915" /></a>
</div>
<p>Given this information, we can go through the same procedure again to construct <span class="math notranslate nohighlight">\(c^+ c^-\)</span>, <span class="math notranslate nohighlight">\(c^- c^+\)</span> and <span class="math notranslate nohighlight">\(N\)</span> operators as <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>s over <span class="math notranslate nohighlight">\(f\mathbb{Z}_2\)</span>-graded vector spaces.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vect</span><span class="p">[</span><span class="n">FermionParity</span><span class="p">](</span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Vect[FermionParity](0=&gt;1, 1=&gt;1)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">c⁺c⁻</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="n">odd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FermionParity</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">c⁺c⁻</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">s</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">coupled</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">odd</span>
<span class="w">        </span><span class="n">c⁺c⁻</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
<span class="n">c⁺c⁻</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap((Vect[FermionParity](0=&gt;1, 1=&gt;1) ⊗ Vect[FermionParity](0=&gt;1, 1=&gt;1)) ← (Vect[FermionParity](0=&gt;1, 1=&gt;1) ⊗ Vect[FermionParity](0=&gt;1, 1=&gt;1))):
* Data for sector (FermionParity(0), FermionParity(0)) ← (FermionParity(0), FermionParity(0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(1)) ← (FermionParity(0), FermionParity(0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(0), FermionParity(0)) ← (FermionParity(1), FermionParity(1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(1)) ← (FermionParity(1), FermionParity(1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(0)) ← (FermionParity(1), FermionParity(0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(0), FermionParity(1)) ← (FermionParity(1), FermionParity(0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(0)) ← (FermionParity(0), FermionParity(1)):
[:, :, 1, 1] =
 1.0 + 0.0im
* Data for sector (FermionParity(0), FermionParity(1)) ← (FermionParity(0), FermionParity(1)):
[:, :, 1, 1] =
 0.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">c⁻c⁺</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">c⁻c⁺</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">coupled</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">odd</span>
<span class="w">        </span><span class="n">c⁻c⁺</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
<span class="n">c⁻c⁺</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap((Vect[FermionParity](0=&gt;1, 1=&gt;1) ⊗ Vect[FermionParity](0=&gt;1, 1=&gt;1)) ← (Vect[FermionParity](0=&gt;1, 1=&gt;1) ⊗ Vect[FermionParity](0=&gt;1, 1=&gt;1))):
* Data for sector (FermionParity(0), FermionParity(0)) ← (FermionParity(0), FermionParity(0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(1)) ← (FermionParity(0), FermionParity(0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(0), FermionParity(0)) ← (FermionParity(1), FermionParity(1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(1)) ← (FermionParity(1), FermionParity(1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(0)) ← (FermionParity(1), FermionParity(0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(0), FermionParity(1)) ← (FermionParity(1), FermionParity(0)):
[:, :, 1, 1] =
 -1.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(0)) ← (FermionParity(0), FermionParity(1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(0), FermionParity(1)) ← (FermionParity(0), FermionParity(1)):
[:, :, 1, 1] =
 0.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">c⁺c⁺</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="n">odd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FermionParity</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">c⁺c⁺</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">s</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">coupled</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">odd</span>
<span class="w">        </span><span class="n">c⁺c⁺</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
<span class="n">c⁺c⁺</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap((Vect[FermionParity](0=&gt;1, 1=&gt;1) ⊗ Vect[FermionParity](0=&gt;1, 1=&gt;1)) ← (Vect[FermionParity](0=&gt;1, 1=&gt;1) ⊗ Vect[FermionParity](0=&gt;1, 1=&gt;1))):
* Data for sector (FermionParity(0), FermionParity(0)) ← (FermionParity(0), FermionParity(0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(1)) ← (FermionParity(0), FermionParity(0)):
[:, :, 1, 1] =
 1.0 + 0.0im
* Data for sector (FermionParity(0), FermionParity(0)) ← (FermionParity(1), FermionParity(1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(1)) ← (FermionParity(1), FermionParity(1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(0)) ← (FermionParity(1), FermionParity(0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(0), FermionParity(1)) ← (FermionParity(1), FermionParity(0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(0)) ← (FermionParity(0), FermionParity(1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(0), FermionParity(1)) ← (FermionParity(0), FermionParity(1)):
[:, :, 1, 1] =
 0.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">c⁻c⁻</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">c⁻c⁻</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">s</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">coupled</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">odd</span>
<span class="w">        </span><span class="n">c⁻c⁻</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
<span class="n">c⁻c⁻</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap((Vect[FermionParity](0=&gt;1, 1=&gt;1) ⊗ Vect[FermionParity](0=&gt;1, 1=&gt;1)) ← (Vect[FermionParity](0=&gt;1, 1=&gt;1) ⊗ Vect[FermionParity](0=&gt;1, 1=&gt;1))):
* Data for sector (FermionParity(0), FermionParity(0)) ← (FermionParity(0), FermionParity(0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(1)) ← (FermionParity(0), FermionParity(0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(0), FermionParity(0)) ← (FermionParity(1), FermionParity(1)):
[:, :, 1, 1] =
 -1.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(1)) ← (FermionParity(1), FermionParity(1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(0)) ← (FermionParity(1), FermionParity(0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(0), FermionParity(1)) ← (FermionParity(1), FermionParity(0)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(1), FermionParity(0)) ← (FermionParity(0), FermionParity(1)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for sector (FermionParity(0), FermionParity(1)) ← (FermionParity(0), FermionParity(1)):
[:, :, 1, 1] =
 0.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="w">    </span><span class="n">N</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">coupled</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">odd</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span>
<span class="k">end</span>
<span class="n">N</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap(Vect[FermionParity](0=&gt;1, 1=&gt;1) ← Vect[FermionParity](0=&gt;1, 1=&gt;1)):
* Data for sector (FermionParity(0),) ← (FermionParity(0),):
 0.0 + 0.0im
* Data for sector (FermionParity(1),) ← (FermionParity(1),):
 1.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Working with fermionic systems is inherently tricky, as can already be seen from something as simple as computing matrix elements of fermionic operators. Similarly, while constructing symmetric tensors that correspond to the symmetric Hamiltonian terms was still quite straightforward, it is far less clear in this case how to construct these terms as contractions of local symmetric tensors representing individual creation and annihilation operators in this case. While such a decomposition can always be in principle obtained using a (now explicitly fermionic) SVD, manually constructing such tensors as we did in the bosonic case is far from trivial. Trying this would be a good exercise in working with fermionic symmetries, but it is not something we will do here.</p>
</div>
</div>
</div>
<div class="section" id="level-4-non-abelian-symmetries-and-the-quantum-heisenberg-model">
<h2><span class="section-number">18.5. </span>Level 4: Non-Abelian Symmetries and the Quantum Heisenberg Model<a class="headerlink" href="#level-4-non-abelian-symmetries-and-the-quantum-heisenberg-model" title="Permalink to this heading">#</a></h2>
<p>We will now move on to systems which have more complicated <em>non-Abelian</em> symmetries. For a non-Abelian symmetry group <span class="math notranslate nohighlight">\(G\)</span>, the fact that its elements do not all commute has a profound impact on its representation theory. In particular, the irreps of such a group can be higher dimensional, and the fusion of two irreps can give rise to multiple different irreps. On the one hand this means that fusion trees of these irreps are no longer completely determined by the uncoupled charges. Indeed, in this case some of the <a class="reference internal" href="#fusion-trees"><span class="std std-ref">internal structure of the <code class="docutils literal notranslate"><span class="pre">FusionTree</span></code> type</span></a> we have ignored before will become relevant (of which we will give an <a class="reference internal" href="#sun-heisenberg"><span class="std std-ref">example below</span></a>). On the other hand, it follows that fusion trees of irreps now not only label blocks, but also encode a certain <em>nontrivial symmetry structure</em>. We will make this statement more precise in the following, but the fact that this is necessary is quite intuitive. If we recall our original statement that symmetric tensors consist of blocks associated to fusion trees which carry irrep labels, then for higher-dimensional irreps the corresponding fusion trees must encode some additional information that implicitly takes into account the internal structure of the representation spaces. In particular, this means that the conversion of an operator, given its matrix elements in the irrep basis, to the blocks of the corresponding symmetric <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> is less straightforward since it requires an understanding of exactly what this implied internal structure is. Therefore, we require some more discussion before we can actually move on to an example.</p>
<p>We’ll start by discussing the general structure of a <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> which is symmetric under a non-Abelian group symmetry. We then given an example based on <span class="math notranslate nohighlight">\(\mathrm{SU}(2)\)</span>, where we construct the Heisenberg Hamiltonian using two different approaches. Finally, we show how the more intuitive approach can be used to obtain an elegant generalization to the <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span>-symmetric case.</p>
<div class="section" id="block-sparsity-revisited-the-wigner-eckart-theorem">
<h3><span class="section-number">18.5.1. </span>Block Sparsity Revisited: The Wigner-Eckart Theorem<a class="headerlink" href="#block-sparsity-revisited-the-wigner-eckart-theorem" title="Permalink to this heading">#</a></h3>
<p>Let us recall some basics of representation theory first. Consider a group <span class="math notranslate nohighlight">\(G\)</span> and a corresponding representation space <span class="math notranslate nohighlight">\(V\)</span>, such that every element <span class="math notranslate nohighlight">\(g \in G\)</span> can be realized as a unitary operator <span class="math notranslate nohighlight">\(U_g : V \to V\)</span>. Let <span class="math notranslate nohighlight">\(h\)</span> be a <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> whose domain and codomain are given by the tensor product of two of these representation spaces. Recall that, by definition, the statement that ‘<span class="math notranslate nohighlight">\(h\)</span> is symmetric under <span class="math notranslate nohighlight">\(G\)</span>’ means that</p>
<div class="figure align-default" id="symmetric-tensor">
<a class="reference internal image-reference" href="../_images/symmetric_tensor.svg"><img alt="../_images/symmetric_tensor.svg" height="151" src="../_images/symmetric_tensor.svg" width="155" /></a>
</div>
<p>for every <span class="math notranslate nohighlight">\(g \in G\)</span>. If we label the irreducible representations of <span class="math notranslate nohighlight">\(G\)</span> by <span class="math notranslate nohighlight">\(l\)</span>, then any representation space can be decomposed into a direct sum of irreducible representations, <span class="math notranslate nohighlight">\(V = \bigoplus_l V^{(l)}\)</span>, in such a way that <span class="math notranslate nohighlight">\(U_g\)</span> is block-diagonal where each block is labeled by a particular irrep <span class="math notranslate nohighlight">\(l\)</span>. For each irrep space <span class="math notranslate nohighlight">\(V^{(l)}\)</span> we can define an orthonormal basis labeled as <span class="math notranslate nohighlight">\(\ket{l, m}\)</span>, where the auxiliary label <span class="math notranslate nohighlight">\(m\)</span> can take <span class="math notranslate nohighlight">\(\text{dim}\left( V^{(l)} \right)\)</span> different values. Since we know that tensors are multilinear maps over tensor product spaces, it is natural to consider the tensor product of representation spaces in more detail.</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Tensor_product_of_representations#Clebsch%E2%80%93Gordan_theory">From the representation theory of groups</a>, it is known that the product of two irreps can in turn be decomposed into a direct sum of irreps, <span class="math notranslate nohighlight">\(V^{(l_1)} \otimes V^{(l_2)} \cong \bigoplus_{k} V^{(k)}\)</span>. The precise nature of this decomposition, also refered to as the <em>Clebsch-Gordan problem</em>, is given by the so-called <em>Clebsch-Gordan coefficients</em>, which we will denote as <span class="math notranslate nohighlight">\(C^{k}_{l_1,l_2}\)</span>. This set of coefficients, which can be interpreted as a <span class="math notranslate nohighlight">\(\text{dim}\left( V^{(l_1)} \right) \times \text{dim}\left( V^{(l_2)} \right)  \times \text{dim}\left( V^{(l_3)} \right)\)</span> array, that encodes how a basis state <span class="math notranslate nohighlight">\(\ket{k,n} \in V^{(k)}\)</span> corresponding to some term in the direct sum can be decomposed into a linear combination of basis vectors <span class="math notranslate nohighlight">\(\ket{l_1,m_1} \otimes \ket{l_2,m_2}\)</span> of the tensor product space:</p>
<div class="math notranslate nohighlight">
\[\ket{k,n} = \sum_{m_1, m_2} \left( C^{l_3}_{l_1,l_2} \right)^{n}_{m_1, m_2} \ket{l_1,m_1} \otimes \ket{l_2,m_2}.\]</div>
<p>These recoupling coefficients turn out to be essential to the structure of symmetric tensors, which can be best understood in the context of the <a class="reference external" href="https://en.wikipedia.org/wiki/Wigner%E2%80%93Eckart_theorem">Wigner-Eckart theorem</a>. This theorem implies that for any <a class="reference internal" href="#symmetric-tensor"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> <span class="math notranslate nohighlight">\(h\)</span> that is symmetric under <span class="math notranslate nohighlight">\(G\)</span></span></a>, its matrix elements in the tensor product irrep basis are given by the product of Clebsch-Gordan coefficients which characterize the coupling of the basis states in the domain and codomain, and a so-called <em>reduced matrix element</em> which only depends on the irrep labels. Concretely, the matrix element <span class="math notranslate nohighlight">\(\bra{l_1,m_1} \otimes \bra{l_2,m_2} h \ket{l_3,m_3} \otimes \ket{l_4,m_4}\)</span> is given by</p>
<div class="figure align-default" id="wignereckart">
<a class="reference internal image-reference" href="../_images/wignereckart.svg"><img alt="../_images/wignereckart.svg" height="178" src="../_images/wignereckart.svg" width="328" /></a>
</div>
<p>Here, the sum runs over all possible irreps <span class="math notranslate nohighlight">\(k\)</span> in the fusion product <span class="math notranslate nohighlight">\(l_3 \otimes l_4\)</span> and over all basis states <span class="math notranslate nohighlight">\(\ket{k,n}\)</span> of <span class="math notranslate nohighlight">\(V^{(k)}\)</span>. The reduced matrix elements <span class="math notranslate nohighlight">\(h_{\text{red}}\)</span> are independent of the basis state labels and only depend on the irrep labels themselves. Each reduced matrix element should be interpreted as being labeled by an irrep fusion tree,</p>
<div class="figure align-default" id="anotherfusiontree">
<a class="reference internal image-reference" href="../_images/anotherfusiontree.svg"><img alt="../_images/anotherfusiontree.svg" height="134" src="../_images/anotherfusiontree.svg" width="145" /></a>
</div>
<p>The fusion tree itself in turn implies the Clebsch-Gordan coefficients <span class="math notranslate nohighlight">\(C^{k}_{l_1,l_2}\)</span> and conjugate coefficients <span class="math notranslate nohighlight">\({C^{\dagger}}_{k}^{l_1,l_2}\)</span> encode the splitting (decomposition) of the coupled basis state <span class="math notranslate nohighlight">\(\ket{k,n}\)</span> to the codomain basis states <span class="math notranslate nohighlight">\(\ket{l_1,m_1} \otimes \ket{l_2,m_2}\)</span> and the coupling of the domain basis states <span class="math notranslate nohighlight">\(\ket{l_3,m_3} \otimes \ket{l_4,m_4}\)</span> to the coupled basis state <span class="math notranslate nohighlight">\(\ket{k,n}\)</span> respectively.</p>
<p>The Wigner-Eckart theorem dictates that this structure in terms of Clebsch-Gordan coefficients is necessary to ensure that the corresponding is symmetric. It is precisely this structure that is inherently encoded into the fusion tree part of a symmetric <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>. In particular, <strong>the array block value associated to each fusion tree in a symmetric tensor is precisely the reduced matrix element in the Clebsch-Gordan decomposition</strong>.</p>
<p>As a small demonstration of this fact, we can make a simple <span class="math notranslate nohighlight">\(\mathrm{SU}(2)\)</span>-symmetric tensor with trivial block values and verify that its implied symmetry structure exactly corresponds to the expected Clebsch-Gordan coefficient. In TensorKit.jl, a <span class="math notranslate nohighlight">\(\mathrm{SU}(2)\)</span>-graded vector space is represented as an <a class="reference external" href="https://jutho.github.io/TensorKit.jl/latest/lib/spaces/#TensorKit.SU2Space"><code class="docutils literal notranslate"><span class="pre">SU2Space</span></code></a>, where a given <span class="math notranslate nohighlight">\(\mathrm{SU}(2)\)</span> irrep can be represented as an <a class="reference external" href="https://jutho.github.io/TensorKit.jl/latest/lib/sectors/#TensorKit.SU2Irrep"><code class="docutils literal notranslate"><span class="pre">SU2Irrep</span></code></a> instance of integer or halfinteger spin as encoded in its <code class="docutils literal notranslate"><span class="pre">j</span></code> field. If we construct a <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> whose symmetry structure corresponds to the coupling of two spin-<span class="math notranslate nohighlight">\(\frac{1}{2}\)</span> irreps to a spin-<span class="math notranslate nohighlight">\(1\)</span> irrep, we can then convert it to a plain array and compare it to the <span class="math notranslate nohighlight">\(\mathrm{SU}(2)\)</span> Clebsch-Gordan coefficients exported by the <a class="reference external" href="https://github.com/Jutho/WignerSymbols.jl">WignerSymbols.jl package</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">V1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SU2Space</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="n">V2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SU2Space</span><span class="p">(</span><span class="mi">1</span><span class="o">//</span><span class="mi">2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V1</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V2</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap(Rep[SU₂](1=&gt;1) ← (Rep[SU₂](1/2=&gt;1) ⊗ Rep[SU₂](1/2=&gt;1))):
* Data for fusiontree FusionTree{Irrep[SU₂]}((1,), 1, (false,), ()) ← FusionTree{Irrep[SU₂]}((1/2, 1/2), 1, (false, false), ()):
[:, :, 1] =
 1.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">ta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convert</span><span class="p">(</span><span class="kt">Array</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3×2×2 Array{ComplexF64, 3}:
[:, :, 1] =
 1.0+0.0im       0.0+0.0im
 0.0+0.0im  0.707107+0.0im
 0.0+0.0im       0.0+0.0im

[:, :, 2] =
      0.0+0.0im  0.0+0.0im
 0.707107+0.0im  0.0+0.0im
      0.0+0.0im  1.0+0.0im
</pre></div>
</div>
</div>
</div>
<p>The conversion gives us a <span class="math notranslate nohighlight">\(3 \times 3 \times 2\)</span> array, which exactly corresponds to the size of the <span class="math notranslate nohighlight">\(C_{1}^{\frac{1}{2},\frac{1}{2}}\)</span> Clebsch-Gordan array. In order to explicitly compare whether the entries match we need to know the ordering of basis states assumed by TensorKit.jl when converting the tensor to its matrix elements in the irrep basis. For <span class="math notranslate nohighlight">\(\mathrm{SU}(2)\)</span> the irrep basis is ordered in ascending magnetic quantum number <span class="math notranslate nohighlight">\(m\)</span>, which gives us a map <span class="math notranslate nohighlight">\(m = i - (l+1)\)</span> for mapping an array index to a corresponding magnetic quantum number for the spin-<span class="math notranslate nohighlight">\(l\)</span> irrep.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">dim</span><span class="p">(</span><span class="n">V1</span><span class="p">),</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">dim</span><span class="p">(</span><span class="n">V2</span><span class="p">),</span><span class="w"> </span><span class="n">i3</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="n">dim</span><span class="p">(</span><span class="n">V2</span><span class="p">)</span>
<span class="w">    </span><span class="c"># map basis state index to magnetic quantum number</span>
<span class="w">    </span><span class="n">m1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">m2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">//</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">m3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">//</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="nd">@test</span><span class="w"> </span><span class="n">ta</span><span class="p">[</span><span class="n">i1</span><span class="p">,</span><span class="w"> </span><span class="n">i2</span><span class="p">,</span><span class="w"> </span><span class="n">i3</span><span class="p">]</span><span class="w"> </span><span class="o">≈</span><span class="w"> </span><span class="n">clebschgordan</span><span class="p">(</span><span class="mi">1</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">m2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">m3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
</div>
<p>Based on this discussion, we can quantify the aforementioned ‘difficulties’ in the inverse operation of what we just demonstrated, namely converting a given operator to a symmetric <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> given only its matrix elements in the irrep basis. Indeed, it is now clear that this precisely requires isolating the reduced matrix elements introduced above. Given the matrix elements of the operator in the irrep basis, this can in general be done by solving the system of equations implied by the <a class="reference internal" href="#wignereckart"><span class="std std-ref">Clebsch-Gordan decomposition</span></a>. A simpler way to achieve the same thing is to make use of the fact that the <a class="reference external" href="https://en.wikipedia.org/wiki/Clebsch%E2%80%93Gordan_coefficients#Orthogonality_relations">Clebsch-Gordan tensors form a complete orthonormal basis</a> on the coupled space. Indeed, by projecting out the appropriate Clebsch-Gordan coefficients and using their orthogonality relations, we can construct a diagonal operator on each coupled irrep space <span class="math notranslate nohighlight">\(V^{(k)}\)</span>. Each of these diagonal operators is proportional to the identity, where the proportionality factor is precisely the reduced matrix element associated to the corresponding irrep fusion tree.</p>
<div class="figure align-default" id="none2symm">
<a class="reference internal image-reference" href="../_images/none2symm.svg"><img alt="../_images/none2symm.svg" height="182" src="../_images/none2symm.svg" width="197" /></a>
</div>
<p>This procedure works for any group symmetry, and all we need are matrix elements of the operator in the irrep basis and the Clebsch-Gordan coefficients. In the following we demonstrate this explicit procedure for the particular example of <span class="math notranslate nohighlight">\(G = \mathrm{SU}(2)\)</span>. However, it should be noted that for general groups the Clebsch-Gordan coefficients may not be as easy to compute (if it is even known how). In addition, the procedure for manually projecting out the reduced matrix elements requires being particularly careful about the correspondence between the basis states used to define the original matrix elements and those implied by the Clebsch-Gordan coefficients. Therefore, it is often easier to directly construct the symmetric tensor based on some representation theory, as we will see below.</p>
</div>
<div class="section" id="the-generic-approach-to-the-spin-1-heisenberg-model-wigner-eckart-in-action">
<h3><span class="section-number">18.5.2. </span>The ‘Generic’ Approach to the Spin-1 Heisenberg Model: Wigner-Eckart in Action<a class="headerlink" href="#the-generic-approach-to-the-spin-1-heisenberg-model-wigner-eckart-in-action" title="Permalink to this heading">#</a></h3>
<p>Consider the spin-1 Heisenberg model with Hamiltonian</p>
<div class="math notranslate nohighlight">
\[H = J \sum_{\langle i,j \rangle} \vec{S}_i \cdot \vec{S}_j\]</div>
<p>where <span class="math notranslate nohighlight">\(\vec{S} = (S^x, S^y, S^z)\)</span> are the spin operators. The physical Hilbert space at each site is the three-dimensional spin-1 irrep of <span class="math notranslate nohighlight">\(\mathrm{SU}(2)\)</span>. Each two-site exchange operator <span class="math notranslate nohighlight">\(\vec{S}_i \cdot \vec{S}_j\)</span> in the sum commutes with a global transformation <span class="math notranslate nohighlight">\(g \in \mathrm{SU}(2)\)</span>, so that it satisfies the <a class="reference internal" href="#symmetric-tensor"><span class="std std-ref">above symmetry condition</span></a>. Therefore, we can represent it as an <span class="math notranslate nohighlight">\(\mathrm{SU}(2)\)</span>-symmetric <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>, as long as we can isolate its reduced matrix elements.</p>
<p>In order to apply the above procedure, we first require the matrix elements in the irrep basis. These can be constructed as a <span class="math notranslate nohighlight">\(3 \times 3 \times 3 \times 3\)</span> array <code class="docutils literal notranslate"><span class="pre">SS</span></code> using the <a class="reference external" href="https://en.wikipedia.org/wiki/Spin_(physics)#Higher_spins">familiar representation of the <span class="math notranslate nohighlight">\(\mathrm{SU}(2)\)</span> generators in the spin-1 representation</a>, with respect to the <span class="math notranslate nohighlight">\(\{\ket{1,-1}, \ket{1,0}, \ket{1,1}\}\)</span> basis.</p>
<div class="cell tag_hide-output docutils container">
<div class="cell_input above-output-prompt docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">Sx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span>
<span class="n">Sy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="nb">im</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="nb">im</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="nb">im</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="nb">im</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span>
<span class="n">Sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span>

<span class="nd">@tensor</span><span class="w"> </span><span class="n">SS_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">Sx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Sx</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Sy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Sy</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Sz</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Sz</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
</div>
<details class="hide below-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell output</span>
<span class="expanded">Hide code cell output</span>
</summary>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3×3×3×3 Array{ComplexF64, 4}:
[:, :, 1, 1] =
 1.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im

[:, :, 2, 1] =
 0.0+0.0im  1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im

[:, :, 3, 1] =
  0.0+0.0im  0.0+0.0im  0.0+0.0im
  0.0+0.0im  1.0+0.0im  0.0+0.0im
 -1.0+0.0im  0.0+0.0im  0.0+0.0im

[:, :, 1, 2] =
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 1.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im

[:, :, 2, 2] =
 0.0+0.0im  0.0+0.0im  1.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 1.0+0.0im  0.0+0.0im  0.0+0.0im

[:, :, 3, 2] =
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  1.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im

[:, :, 1, 3] =
 0.0+0.0im  0.0+0.0im  -1.0+0.0im
 0.0+0.0im  1.0+0.0im   0.0+0.0im
 0.0+0.0im  0.0+0.0im   0.0+0.0im

[:, :, 2, 3] =
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im

[:, :, 3, 3] =
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  1.0+0.0im
</pre></div>
</div>
</div>
</details>
</div>
<p>The next step is to project out the reduced matrix elements by taking the overlap with the appropriate Clebsch-Gordan coefficients, according to <a class="reference internal" href="#none2symm"><span class="std std-ref">the Clebsch-Gordan decomposition given above</span></a>. In our current case of a spin-1 physical space we have <span class="math notranslate nohighlight">\(l_1 = l_2 = l_3 = l_4 = 1\)</span>, and the coupled irrep <span class="math notranslate nohighlight">\(k\)</span> can therefore take the values <span class="math notranslate nohighlight">\(0, 1, 2\)</span>. The reduced matrix element for a given <span class="math notranslate nohighlight">\(k\)</span> can then be implemented in the following way:</p>
<div class="cell tag_hide-output docutils container">
<div class="cell_input above-output-prompt docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="n">get_reduced_element</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="w">    </span><span class="c"># construct Clebsch-Gordan coefficients for coupling 1 ⊗ 1 to k   </span>
<span class="w">    </span><span class="n">CG</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeros</span><span class="p">(</span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">-</span><span class="n">k</span><span class="o">:</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">m2</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">m3</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">1</span>
<span class="w">        </span><span class="n">CG</span><span class="p">[</span><span class="n">m2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">m3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clebschgordan</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">m2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">m3</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c"># project out diagonal matrix on coupled irrep space</span>
<span class="w">    </span><span class="nd">@tensor</span><span class="w"> </span><span class="n">reduced_matrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">CG</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">SS_arr</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">conj</span><span class="p">(</span><span class="n">CG</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

<span class="w">    </span><span class="c"># check that it is proportianal to the identity</span>
<span class="w">    </span><span class="nd">@assert</span><span class="w"> </span><span class="n">isapprox</span><span class="p">(</span><span class="n">reduced_matrix</span><span class="p">,</span><span class="w"> </span><span class="n">reduced_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">I</span><span class="p">;</span><span class="w"> </span><span class="n">atol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>

<span class="w">    </span><span class="c"># return the proportionality factor</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">reduced_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
<details class="hide below-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell output</span>
<span class="expanded">Hide code cell output</span>
</summary>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>get_reduced_element (generic function with 1 method)
</pre></div>
</div>
</div>
</details>
</div>
<p>If we use this to compute the reduced matrix elements for <span class="math notranslate nohighlight">\(k = 0, 1, 2\)</span>,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">get_reduced_element</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-1.9999999999999993 + 0.0im
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">get_reduced_element</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-1.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">get_reduced_element</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<p>we can read off the entries</p>
<div class="math notranslate nohighlight">
\[\begin{split}\renewcommand\thickspace{\kern .01ex}
\left[ (\vec{S}_i \cdot \vec{S}_j)_\text{red} \right] \,\,\!\!
\begin{smallmatrix}
    1,1\\
    0\\
    1,1
\end{smallmatrix} = -2, \quad
\left[ (\vec{S}_i \cdot \vec{S}_j)_\text{red} \right] \,\,\!\!
\begin{smallmatrix}
    1,1\\
    1\\
    1,1
\end{smallmatrix} = -1, \quad
\left[ (\vec{S}_i \cdot \vec{S}_j)_\text{red} \right] \,\,\!\!
\begin{smallmatrix}
    1,1\\
    2\\
    1,1
\end{smallmatrix} = 1, \quad\end{split}\]</div>
<p>These can then be used to construct the symmetric <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> representing the exchange interaction:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SU2Space</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="n">SS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">SS</span><span class="p">)</span>
<span class="w">    </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">Int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">coupled</span><span class="o">.</span><span class="n">j</span><span class="p">)</span>
<span class="w">    </span><span class="n">SS</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="n">get_reduced_element</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="k">end</span>
<span class="n">SS</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap((Rep[SU₂](1=&gt;1) ⊗ Rep[SU₂](1=&gt;1)) ← (Rep[SU₂](1=&gt;1) ⊗ Rep[SU₂](1=&gt;1))):
* Data for fusiontree FusionTree{Irrep[SU₂]}((1, 1), 0, (false, false), ()) ← FusionTree{Irrep[SU₂]}((1, 1), 0, (false, false), ()):
[:, :, 1, 1] =
 -1.9999999999999993 + 0.0im
* Data for fusiontree FusionTree{Irrep[SU₂]}((1, 1), 1, (false, false), ()) ← FusionTree{Irrep[SU₂]}((1, 1), 1, (false, false), ()):
[:, :, 1, 1] =
 -1.0 + 0.0im
* Data for fusiontree FusionTree{Irrep[SU₂]}((1, 1), 2, (false, false), ()) ← FusionTree{Irrep[SU₂]}((1, 1), 2, (false, false), ()):
[:, :, 1, 1] =
 1.0 + 0.0im
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="an-elegant-approach-to-the-heisenberg-model">
<h3><span class="section-number">18.5.3. </span>An ‘Elegant’ Approach to the Heisenberg Model<a class="headerlink" href="#an-elegant-approach-to-the-heisenberg-model" title="Permalink to this heading">#</a></h3>
<p>As noted above, the explicit procedure of projecting out the reduced matrix elements from the action of an operator in the irrep basis can be a bit cumbersome for more complicated groups. However, using some basic representation theory we can bypass this step altogether for the Heisenberg model. First, we rewrite the exchange interaction in the following way:</p>
<div class="math notranslate nohighlight" id="equation-eq-casimir-decomp">
<span class="eqno">(18.6)<a class="headerlink" href="#equation-eq-casimir-decomp" title="Permalink to this equation">#</a></span>\[\vec{S}_i \cdot \vec{S}_j = \frac{1}{2} \left( \left( \vec{S}_i + \vec{S}_j \right)^2 - \vec{S}_i^2 - \vec{S}_j^2 \right)\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\vec{S}_i\)</span> and <span class="math notranslate nohighlight">\(\vec{S}_j\)</span> are spin operators on the physcial irrep, while total spin operator <span class="math notranslate nohighlight">\(\vec{S}_i + \vec{S}_j\)</span> can be decomposed onto the different coupled irreps <span class="math notranslate nohighlight">\(k\)</span>. It is a well known fact that the quadratic sum of the generators of <span class="math notranslate nohighlight">\(\mathrm{SU}(2)\)</span>, often refered to as the <a class="reference external" href="https://en.wikipedia.org/wiki/Representation_theory_of_SU(2)#The_Casimir_element"><em>quadratic Casimir</em></a>, commutes with all generators. By <a class="reference external" href="https://en.wikipedia.org/wiki/Schur%27s_lemma">Schur’s lemma</a>, it must then act proportional to the identity on every irrep, where the corresponding eigenvalue is determined by the spin irrep label. In particular, we have for each irrep <span class="math notranslate nohighlight">\(l\)</span></p>
<div class="math notranslate nohighlight">
\[\vec{S}^2 \ket{l,m} = l(l+1) \ket{l,m}.\]</div>
<p>It then follows from Eq. <a class="reference internal" href="#equation-eq-casimir-decomp">(18.6)</a> that the reduced matrix elements of the exchange interaction are completely determined by the eigenvalue of the quadratic Casimir on the uncoupled and coupled irreps. Indeed, to each fusion tree we can associate a well-defined value</p>
<div class="figure align-default" id="su2-fusiontrees">
<a class="reference internal image-reference" href="../_images/SU2_fusiontrees.svg"><img alt="../_images/SU2_fusiontrees.svg" height="134" src="../_images/SU2_fusiontrees.svg" width="462" /></a>
</div>
<p>This gives us all we need to directly construct the exchange interaction as a symmetric <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code>,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SU2Space</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="n">SS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">SS</span><span class="p">)</span>
<span class="w">    </span><span class="n">l3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">j</span>
<span class="w">    </span><span class="n">l4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">j</span>
<span class="w">    </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">coupled</span><span class="o">.</span><span class="n">j</span>
<span class="w">    </span><span class="n">SS</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">l3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">l4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">l4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span>
<span class="k">end</span>
<span class="n">SS</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap((Rep[SU₂](1=&gt;1) ⊗ Rep[SU₂](1=&gt;1)) ← (Rep[SU₂](1=&gt;1) ⊗ Rep[SU₂](1=&gt;1))):
* Data for fusiontree FusionTree{Irrep[SU₂]}((1, 1), 0, (false, false), ()) ← FusionTree{Irrep[SU₂]}((1, 1), 0, (false, false), ()):
[:, :, 1, 1] =
 -2.0 + 0.0im
* Data for fusiontree FusionTree{Irrep[SU₂]}((1, 1), 1, (false, false), ()) ← FusionTree{Irrep[SU₂]}((1, 1), 1, (false, false), ()):
[:, :, 1, 1] =
 -1.0 + 0.0im
* Data for fusiontree FusionTree{Irrep[SU₂]}((1, 1), 2, (false, false), ()) ← FusionTree{Irrep[SU₂]}((1, 1), 2, (false, false), ()):
[:, :, 1, 1] =
 1.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<p>which gives exactly the same result as the previous approach.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This last construction for the exchange interaction immediatly generalizes to any value of the physical spin. All we need is to fill in the appropriate values for the uncoupled irreps <span class="math notranslate nohighlight">\(l_1\)</span>, <span class="math notranslate nohighlight">\(l_2\)</span>, <span class="math notranslate nohighlight">\(l_3\)</span> and <span class="math notranslate nohighlight">\(l_4\)</span>.</p>
</div>
</div>
<div class="section" id="mathrm-su-n-generalization">
<span id="sun-heisenberg"></span><h3><span class="section-number">18.5.4. </span><span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> generalization<a class="headerlink" href="#mathrm-su-n-generalization" title="Permalink to this heading">#</a></h3>
<p>We end this subsection with some comments on the generalization of the above discussion to <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span>. As foreshadowed above, the irreps of <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> in general have an even more complicated structure. In particular, they can admit so-called <em>fusion multiplicities</em>, where the fusion of two irreps can not just have multiple distinct outcomes, but they can even fuse to a given irrep in mutliple inequivalent ways. We can demonstrate this behavior for the adjoint representation of <span class="math notranslate nohighlight">\(\mathrm{SU}(3)\)</span>. For this we can use the the <a class="reference external" href="https://github.com/maartenvd/SUNRepresentations.jl/tree/master">SUNRepresentations.jl</a> package which provides an interface for working with irreps of <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> and their Clebsch-Gordan coefficients. A particular representation is represented by an <code class="docutils literal notranslate"><span class="pre">SUNIrrep{N}</span></code> which can be used with TensorKit.jl. The eight-dimensional adjoint representation of <span class="math notranslate nohighlight">\(\mathrm{SU}(3)\)</span> is given by</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SU3Irrep</span><span class="p">(</span><span class="s">&quot;8&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Irrep[SU₃](&quot;8&quot;)
</pre></div>
</div>
</div>
</div>
<p>If we look at the possible outcomes of fusing two adjoint irreps, we find the by now familiar non-Abelian fusion behavior,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">collect</span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">l</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5-element Vector{SU3Irrep}:
 &quot;1&quot;
 &quot;27&quot;
 &quot;10&quot;
 &quot;8&quot;
 &quot;10⁺&quot;
</pre></div>
</div>
</div>
</div>
<p>However, this particular fusion has multiplicities, since the adjoint irrep can actually fuse to itself in two distinct ways. The full decomposition of this fusion product is given by</p>
<div class="math notranslate nohighlight">
\[\mathbf{8} \otimes \mathbf{8} = \mathbf{1} \oplus \mathbf{3} \oplus 2 \cdot \mathbf{8} \oplus \mathbf{10} \oplus \mathbf{\overline{10}} \oplus \mathbf{27}\]</div>
<p>This fusion multiplicity can be detected by using <a class="reference external" href="https://jutho.github.io/TensorKit.jl/latest/lib/sectors/#TensorKit.Nsymbol"><code class="docutils literal notranslate"><span class="pre">Nsymbol</span></code></a> method from TensorKit.jl to inspect the number of times <code class="docutils literal notranslate"><span class="pre">l</span></code> appears in the fusion product <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">⊗</span> <span class="pre">l</span></code>,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">Nsymbol</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<p>When working with irreps with fusion multiplicities, each <code class="docutils literal notranslate"><span class="pre">FusionTree</span></code> carries additional <code class="docutils literal notranslate"><span class="pre">vertices</span></code> labels which label which of the distinct fusion vertices is being referred to. We will return to this at the end of this section.</p>
<p>Given the generators <span class="math notranslate nohighlight">\(T^k\)</span> of <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span>, we can define a generalized Heisenberg model using a similar exchange interaction, giving the Hamiltonian</p>
<div class="math notranslate nohighlight">
\[H = J \sum_{\langle i,j \rangle} \vec{T}_i \cdot \vec{T}_j\]</div>
<p>For a particular choice of physical irrep, the exchange interaction can again be constructed as a symmetric <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> by first rewriting it as</p>
<div class="math notranslate nohighlight">
\[\vec{T}_i \cdot \vec{T}_j = \frac{1}{2} \left( \left( \vec{T}_i + \vec{T}_j \right)^2 - \vec{T}_i^2 - \vec{T}_j^2 \right).\]</div>
<p>For any <span class="math notranslate nohighlight">\(N\)</span>, the quadratic Casimir</p>
<div class="math notranslate nohighlight">
\[C_1 = \sum_k T^k T^k\]</div>
<p>commutes with all <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> generators, meaning it has a well defined eigenvalue in each irrep. This observation then immediately given the reduced matrix elements of the exchange interaction as</p>
<div class="figure align-default" id="sun-fusiontrees">
<a class="reference internal image-reference" href="../_images/SUN_fusiontrees.svg"><img alt="../_images/SUN_fusiontrees.svg" height="134" src="../_images/SUN_fusiontrees.svg" width="380" /></a>
</div>
<p>Using these to directly construct the corresponding symmetric <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> is much simpler than going through the explicit projection procedure using Clebsch-Gordan coefficients.</p>
<p>For the particular example of <span class="math notranslate nohighlight">\(\mathrm{SU}(3)\)</span>, the generators are given by <span class="math notranslate nohighlight">\(T^k = \frac{1}{2} \lambda^k\)</span> , where <span class="math notranslate nohighlight">\(\lambda^k\)</span> are the <a class="reference external" href="https://en.wikipedia.org/wiki/Clebsch%E2%80%93Gordan_coefficients_for_SU(3)#Generators_of_the_Lie_algebra">Gell-Mann matrices</a>. Each irrep can be labeled as <span class="math notranslate nohighlight">\(l = D(p,q)\)</span> where <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span> are refered to as the <em>Dynkin labels</em>. The eigenvalue of the quadratic Casimir for a given irrep is given by <a class="reference external" href="https://en.wikipedia.org/wiki/Weyl_character_formula#Freudenthal's_formula">Freudenthal’s formula</a>,</p>
<div class="math notranslate nohighlight">
\[C_1(D(p,q)) = \frac{1}{3} (p^2 + q^2 + 3p + 3q + pq).\]</div>
<p>Using SUNRepresentations.jl, we can compute the Casimir as</p>
<div class="cell tag_hide-output docutils container">
<div class="cell_input above-output-prompt docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="n">casimir</span><span class="p">(</span><span class="n">l</span><span class="o">::</span><span class="kt">SUNIrrep</span><span class="p">)</span>
<span class="w">    </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dynkin_label</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">3</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
<details class="hide below-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell output</span>
<span class="expanded">Hide code cell output</span>
</summary>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>casimir (generic function with 1 method)
</pre></div>
</div>
</div>
</details>
</div>
<p>If we use the adjoint representation of <span class="math notranslate nohighlight">\(\mathrm{SU}(3)\)</span> as physical space, the Heisenberg exchange interaction can then be constructed as</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vect</span><span class="p">[</span><span class="kt">SUNIrrep</span><span class="p">{</span><span class="mi">3</span><span class="p">}](</span><span class="n">SU3Irrep</span><span class="p">(</span><span class="s">&quot;8&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="n">TT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span><span class="w"> </span><span class="kt">ComplexF64</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span>
<span class="w">    </span><span class="n">l3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="w">    </span><span class="n">l4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">uncoupled</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="w">    </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">coupled</span>
<span class="w">    </span><span class="n">TT</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="p">(</span><span class="n">casimir</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">casimir</span><span class="p">(</span><span class="n">l3</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">casimir</span><span class="p">(</span><span class="n">l4</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span>
<span class="k">end</span>
<span class="n">TT</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap((Rep[SU₃](&quot;8&quot;=&gt;1) ⊗ Rep[SU₃](&quot;8&quot;=&gt;1)) ← (Rep[SU₃](&quot;8&quot;=&gt;1) ⊗ Rep[SU₃](&quot;8&quot;=&gt;1))):
* Data for fusiontree FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;1&quot;, (false, false),(), (1,)) ← FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;1&quot;, (false, false),(), (1,)):
[:, :, 1, 1] =
 -3.0 + 0.0im
* Data for fusiontree FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;8&quot;, (false, false),(), (2,)) ← FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;8&quot;, (false, false),(), (2,)):
[:, :, 1, 1] =
 -1.5 + 0.0im
* Data for fusiontree FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;8&quot;, (false, false),(), (1,)) ← FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;8&quot;, (false, false),(), (2,)):
[:, :, 1, 1] =
 -1.5 + 0.0im
* Data for fusiontree FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;8&quot;, (false, false),(), (2,)) ← FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;8&quot;, (false, false),(), (1,)):
[:, :, 1, 1] =
 -1.5 + 0.0im
* Data for fusiontree FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;8&quot;, (false, false),(), (1,)) ← FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;8&quot;, (false, false),(), (1,)):
[:, :, 1, 1] =
 -1.5 + 0.0im
* Data for fusiontree FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;10⁺&quot;, (false, false),(), (1,)) ← FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;10⁺&quot;, (false, false),(), (1,)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for fusiontree FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;10&quot;, (false, false),(), (1,)) ← FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;10&quot;, (false, false),(), (1,)):
[:, :, 1, 1] =
 0.0 + 0.0im
* Data for fusiontree FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;27&quot;, (false, false),(), (1,)) ← FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;27&quot;, (false, false),(), (1,)):
[:, :, 1, 1] =
 1.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<p>Circling back to our earlier remark, we clearly see that the fusion trees of this tensor indeed have non-trivial vertex labels.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collect</span><span class="p">(</span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">TT</span><span class="p">))[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>FusionTree{Irrep[SU₃]}((&quot;8&quot;, &quot;8&quot;), &quot;8&quot;, (false, false),(), (2,))
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">vertices</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(2,)
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While we have given an explicit example using <span class="math notranslate nohighlight">\(\mathrm{SU}(3)\)</span> with the adoint irrep on the physical level, the same construction holds for the general <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> with arbitrary physical irreps. All we require is the expression for the eigenvalues of the quadratic Casimir in each irrep.</p>
</div>
</div>
</div>
<div class="section" id="level-5-anyonic-symmetries-and-the-golden-chain">
<h2><span class="section-number">18.6. </span>Level 5: Anyonic Symmetries and the Golden Chain<a class="headerlink" href="#level-5-anyonic-symmetries-and-the-golden-chain" title="Permalink to this heading">#</a></h2>
<p>While we have focussed exclusively on group-like symmetries in our discussion so far, the framework of symmetric actually extends beyond groups to so-called <a class="reference external" href="https://jutho.github.io/TensorKit.jl/stable/man/sectors/#ss_representationtheory"><em>categorical symmetries</em></a>. These are quite exotic symmetries characterized in terms of <a class="reference external" href="https://jutho.github.io/TensorKit.jl/stable/man/categories/#ss_topologicalfusion">the topological data of a unitary fusion category</a>. While the precise details of all the terms in these statements fall beyond the scope of this tutorial, we can give a simple example of a Hamiltonion model with a categorical symmetry called <a class="reference external" href="https://arxiv.org/abs/cond-mat/0612341">the golden chain</a>.</p>
<p>This is a one-dimensional system defined as a spin chain, where each physical ‘spin’ corresponds to a so-called <a class="reference external" href="https://arxiv.org/abs/0902.3275">Fibonacci anyon</a>. There are two such Fibonacci anyons, which we will denote as <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span>. They obey the fusion rules</p>
<div class="math notranslate nohighlight">
\[1 \otimes 1 = 1, \quad 1 \otimes \tau = \tau, \quad \tau \otimes \tau = 1 \oplus \tau.\]</div>
<p>The Hilbert space of a chain of Fibonacci anyons is not a regular tensor product space, but rather a <em>constrained Hilbert space</em> where the only allowed basis states are labeled by valid Fibonacci fusion configurations.
In the golden chain model, we define a nearest-neighbor Hamiltonian on this Hilbert space by imposing an energy penalty when any two neighboring anyons fuse to a <span class="math notranslate nohighlight">\(\tau\)</span> anyon.</p>
<p>Even just writing down an explicit expression for this interaction on such a constrained Hilbert space is not entirely straightforward. However, using the framework of symmetric tensors it can actually be explicitly constructed in a very straightforward way. Indeed, TensorKit.jl supports a dedicated <a class="reference external" href="https://jutho.github.io/TensorKit.jl/latest/lib/sectors/#TensorKit.FibonacciAnyon"><code class="docutils literal notranslate"><span class="pre">FibonacciAnyon</span></code></a> sector type which can be used to construct precisely such a constrained Fibonacci-graded vector space. A Hamiltonian</p>
<div class="math notranslate nohighlight">
\[H = \sum_{\langle i,j \rangle} h_{ij}\]</div>
<p>which favors neighboring anyons fusing to the vacuum can be constructed as a <code class="docutils literal notranslate"><span class="pre">TensorMap</span></code> on the product space of two Fibonacci-graded physical spaces</p>
<div class="cell tag_hide-output docutils container">
<div class="cell_input above-output-prompt docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vect</span><span class="p">[</span><span class="n">FibonacciAnyon</span><span class="p">](</span><span class="ss">:τ</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<details class="hide below-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell output</span>
<span class="expanded">Hide code cell output</span>
</summary>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Vect[FibonacciAnyon](:τ=&gt;1)
</pre></div>
</div>
</div>
</details>
</div>
<p>and assigning the following nonzero block value to the two-site fusion trees</p>
<div class="figure align-default" id="fib-fusiontrees">
<a class="reference internal image-reference" href="../_images/Fib_fusiontrees.svg"><img alt="../_images/Fib_fusiontrees.svg" height="128" src="../_images/Fib_fusiontrees.svg" width="170" /></a>
</div>
<p>This allows us to define this, at first sight, exotic and complicated Hamiltonian in a few simple lines of code,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorMap</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">←</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">⊗</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">fusiontrees</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="w">    </span><span class="n">h</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">.=</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">coupled</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FibonacciAnyon</span><span class="p">(</span><span class="ss">:I</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span>
<span class="k">end</span>
<span class="n">h</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>TensorMap((Vect[FibonacciAnyon](:τ=&gt;1) ⊗ Vect[FibonacciAnyon](:τ=&gt;1)) ← (Vect[FibonacciAnyon](:τ=&gt;1) ⊗ Vect[FibonacciAnyon](:τ=&gt;1))):
* Data for fusiontree FusionTree{FibonacciAnyon}((:τ, :τ), :I, (false, false), ()) ← FusionTree{FibonacciAnyon}((:τ, :τ), :I, (false, false), ()):
[:, :, 1, 1] =
 -1.0 + 0.0im
* Data for fusiontree FusionTree{FibonacciAnyon}((:τ, :τ), :τ, (false, false), ()) ← FusionTree{FibonacciAnyon}((:τ, :τ), :τ, (false, false), ()):
[:, :, 1, 1] =
 0.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the previous section we have stressed the role of Clebsch-Gordan coefficients in the structure of symmetric tensors, and how they can be used to map between the representation of an operator in the irrep basis and its symmetric tensor representation. However, for categorical symmetries such as the Fibonacci anyons, there are no Clebsch-Gordan coefficients. Therefore, the ‘matrix elements of the operator in the irrep basis’ are not well-defined, meaning that a Fibonacci-symmetric tensor cannot actually be converted to a plain array in a meaningful way.</p>
</div>
</div>
<div class="section" id="to-be-added">
<h2><span class="section-number">18.7. </span>To Be Added<a class="headerlink" href="#to-be-added" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>Add section on product symmetries and how to work with them.</p>
<ul>
<li><p>Use the Hubbard model with <span class="math notranslate nohighlight">\(f\mathbb{Z}_2 \boxtimes \mathrm{U}(1) \boxtimes \mathrm{SU}(2)\)</span> as an example.</p></li>
</ul>
</li>
<li><p>Add a section on classical <span class="math notranslate nohighlight">\(O(N)\)</span> models to illustrate the (‘Fourier’) transformation from the group element to the irrep basis for continuous symmetries.</p></li>
</ul>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "julia-1.9"
        },
        kernelOptions: {
            name: "julia-1.9",
            path: "./5-Tutorials"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'julia-1.9'</script>

                    </div>
                    
                </main> <!-- .page__content -->
                


                <footer class="qe-page__footer">

                    <p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://licensebuttons.net/l/by-sa/4.0/80x15.png"></a></p>

                    <p>Creative Commons License &ndash; This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International.</p>

                </footer> <!-- .page__footer -->

            </div> <!-- .page -->

            

            
            <div class="qe-sidebar bd-sidebar inactive" id="site-navigation">

                <div class="qe-sidebar__header">


                    Contents

                </div>

                <nav class="qe-sidebar__nav" id="qe-sidebar-nav" aria-label="Main navigation">
                    <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Preliminaries
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../0-Preliminaries/Software.html">
   1. Getting Started with Numerics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../0-Preliminaries/Resources.html">
   2. Useful Resources
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Introduction to Quantum Many-Body Physics
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../1-Introduction/QuantumMechanics.html">
   3. Quantum Mechanics and its Postulates
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1-Introduction/ManyBody.html">
   4. The Hilbert Space of Many-Body Physics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1-Introduction/FockSpace.html">
   5. Fock Space and Second Quantisation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1-Introduction/Observables.html">
   6. Interesting States and Observables in Quantum Many-Body Physics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1-Introduction/QuantumToClassical.html">
   7. Quantum-to-Classical Mapping
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Tensors and Tensor Networks
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../2-TensorNetworks/LinearAlgebra.html">
   8. (Multi-) Linear Algebra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../2-TensorNetworks/TensorNetworks.html">
   9. Tensor Network Theory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../2-TensorNetworks/TensorNetworkStates.html">
   10. Tensor Network States
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../2-TensorNetworks/Symmetries.html">
   11. Symmetries in Quantum Many-Body Physics
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Matrix Product States
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../3-MatrixProductStates/MatrixProductStates.html">
   12. Matrix Product States
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../3-MatrixProductStates/InfiniteMPS.html">
   13. Infinite Matrix Product States
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../3-MatrixProductStates/Algorithms.html">
   14. A Simple Tensor Network Algorithm
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../3-MatrixProductStates/MatrixProductOperators.html">
   15. Matrix Product Operators and Applications
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Tensor Network Algorithms
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../4-Algorithms/FixedpointAlgorithms.html">
   16. Fixed-Point algorithms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../4-Algorithms/TimeEvolutionAlgorithms.html">
   17. Time Evolution
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  In-Depth Tutorials
 </span>
</p>
<ul class="current nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1 current active active">
  <a class="current reference internal" href="#">
   18. A Symmetric Tensor Deep Dive: Constructing Your First Tensor Map
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="FiniteEntanglementScaling.html">
   19. Finite Entanglement Scaling
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Other
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../References.html">
   20. References
  </a>
 </li>
</ul>

                </nav>

                <div class="qe-sidebar__footer">

                </div>

            </div> <!-- .sidebar -->
            
        </div> <!-- .main -->

        <div class="qe-toolbar">

            <div class="qe-toolbar__inner">

                <ul class="qe-toolbar__main">
                    <li data-tippy-content="Table of Contents" class="btn__sidebar"><i data-feather="menu"></i></li>
                    <li data-tippy-content="Home"><a href="../intro.html"><i data-feather="home"></i></a></li>
                    <li><a href="https://quantumghent.github.io/" title="">QuantumGroup@UGent</a></li>
                    <li><a href="https://github.com/quantumghent/" title="GitHub" rel="external nofollow noopener" target="_blank"><i class="fab fa-github"></i></a></li>
                </ul>

                <ul class="qe-toolbar__links">
                    <li class="btn__search">
                        <form action="../search.html" method="get">
                            <input type="search" class="form-control" name="q" id="search-input" placeholder="Search..." aria-label="Search..." autocomplete="off" accesskey="k">
                            <i data-feather="search" id="search-icon"></i>
                        </form>
                    </li>
                    <li data-tippy-content="Fullscreen" class="btn__fullscreen"><i data-feather="maximize"></i></li>
                    <li data-tippy-content="Increase font size" class="btn__plus"><i data-feather="plus-circle"></i></li>
                    <li data-tippy-content="Decrease font size" class="btn__minus"><i data-feather="minus-circle"></i></li>
                    <li data-tippy-content="Change contrast" class="btn__contrast"><i data-feather="sunset"></i></li>
                    <li class="settings-button" id="settingsButton"><div data-tippy-content="Launch Notebook"><i data-feather="play-circle"></i></div></li>
                        <li data-tippy-content="Download PDF" onClick="window.print()"><i data-feather="file"></i></li>
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/quantumghent/TensorTutorials//blob/main/lectures/5-Tutorials/SymmetricTensors.md" download><i data-feather="github"></i></a></li>
                </ul>

            </div>

        </div> <!-- .toolbar -->
        <div id="downloadPDFModal" style="display: none;">
            <ul class="pdf-options" style="display: block;">
                <li class="download-pdf-book" onClick="window.print()">
                    <p>Lecture (PDF)</p>
                </li>
                <li class="download-pdf-file">
                    <a href="" download><p>Book (PDF)</p></a>
                </li>
            </ul>
        </div>
        <div id="settingsModal" style="display: none;">
            <p class="modal-title"> Notebook Launcher </p>
            <div class="modal-desc">
            <p>
                Choose public or private cloud service for "Launch" button.
            </p>
            </div>
            <p class="modal-subtitle">Select a server</p>
            <ul class="modal-servers">
            <li class="active launcher-public">
                <span class="label">Public</span>
                <select id="launcher-public-input">
                
                    <option value="https://colab.research.google.com/github/quantumghent/TensorTutorials.notebooks/blob/main/5-Tutorials/SymmetricTensors.ipynb">Colab</option>
                
                </select>
                <i class="fas fa-check-circle"></i>
            </li>
            <li class="launcher-private">
                <span class="label">Private</span>
                <input type="text" id="launcher-private-input" data-repourl="https://github.com/quantumghent/TensorTutorials.notebooks/" data-urlpath="tree/TensorTutorials.notebooks/5-Tutorials/SymmetricTensors.ipynb" data-branch=main>
                <i class="fas fa-check-circle"></i>
            </li>
            </ul>
            <p class="launch"><a href="https://colab.research.google.com/github/quantumghent/TensorTutorials.notebooks/blob/main/5-Tutorials/SymmetricTensors.ipynb" id="advancedLaunchButton" target="_blank">Launch Notebook</a></p>
            <script>
                // QuantEcon Notebook Launcher
                const launcherTypeElements = document.querySelectorAll('#settingsModal .modal-servers li');
                // Highlight the server type if previous selection exists
                if (typeof localStorage.launcherType !== 'undefined') {
                  for (var i = 0; i < launcherTypeElements.length; i++) {
                    launcherTypeElements[i].classList.remove('active');
                    if ( launcherTypeElements[i].classList.contains(localStorage.launcherType) ) {
                      launcherTypeElements[i].classList.add('active');
                    }
                  }
                }
                // Highlight server type on click and set local storage value
                for (var i = 0; i < launcherTypeElements.length; i++) {
                  launcherTypeElements[i].addEventListener('click', function() {
                    for (var j = 0; j < launcherTypeElements.length; j++) {
                      launcherTypeElements[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    if ( this.classList.contains('launcher-private') ) {
                      localStorage.launcherType = 'launcher-private';
                    } else if ( this.classList.contains('launcher-public') ) {
                      localStorage.launcherType = 'launcher-public';
                    }
                    setLaunchServer();
                  })
                }
                const launcherPublic = document.getElementById('launcher-public-input');
                const launcherPrivate = document.getElementById('launcher-private-input');
                const pageName = "5-Tutorials/SymmetricTensors";
                const repoURL = "https://github.com/quantumghent/TensorTutorials.notebooks/";
                const urlPath = "tree/TensorTutorials.notebooks/5-Tutorials/SymmetricTensors.ipynb";
                const branch = "main"
                const launchNotebookLink = document.getElementById('advancedLaunchButton');

                // Highlight public server option if previous selection exists
                if (typeof localStorage.launcherPublic !== 'undefined') {
                  launcherPublic.value = localStorage.launcherPublic;
                }
                // Update local storage upon public server selection
                launcherPublic.addEventListener('change', (event) => {
                  setLaunchServer();
                });
                // Populate private server input if previous entry exists
                if (typeof localStorage.launcherPrivate !== 'undefined') {
                  launcherPrivate.value = localStorage.launcherPrivate;
                }
                // Update local storage when a private server is entered
                launcherPrivate.addEventListener('input', (event) => {
                  setLaunchServer();
                });

                // Function to update the "Launch Notebook" link href
                function setLaunchServer() {
                  launchNotebookLink.removeAttribute("style")
                  if ( localStorage.launcherType == 'launcher-private' ) {
                    let repoPrefix = "/jupyter/hub/user-redirect/git-pull?repo=" + repoURL + "&branch=" + branch + "&urlpath=" + urlPath;
                    launcherPrivateValue = launcherPrivate.value
                    if (!launcherPrivateValue) {
                        launchNotebookLink.removeAttribute("href")
                        launchNotebookLink.style.background = "grey"
                        return
                    }
                    localStorage.launcherPrivate = launcherPrivateValue;
                    privateServer = localStorage.launcherPrivate.replace(/\/$/, "")
                    if (!privateServer.includes("http")) {
                        privateServer = "http://" + privateServer
                    }
                    launchNotebookLinkURL = privateServer + repoPrefix;
                  } else if ( localStorage.launcherType == 'launcher-public' ) {
                    launcherPublicValue = launcherPublic.options[launcherPublic.selectedIndex].value;
                    localStorage.launcherPublic = launcherPublicValue;
                    launchNotebookLinkURL = localStorage.launcherPublic;
                  }
                  if (launchNotebookLinkURL) launchNotebookLink.href = launchNotebookLinkURL;
                }
                // Check if user has previously selected a server
                if ( (typeof localStorage.launcherPrivate !== 'undefined') || (typeof localStorage.launcherPublic !== 'undefined') ) {
                  setLaunchServer();
                }
                </script>

        </div>

    </div> <!-- .wrapper-->
  </body>
</html>